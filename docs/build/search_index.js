var documenterSearchIndex = {"docs":
[{"location":"api/#Exported-SimplexTableaux-Functions-and-their-Docstrings","page":"API","title":"Exported  SimplexTableaux Functions and their Docstrings","text":"","category":"section"},{"location":"api/#SimplexTableaux.Tableau","page":"API","title":"SimplexTableaux.Tableau","text":"Tableau(A::Matrix, b::Vector, c::Vector, canonical::Bool=false)\n\nIf the LP is in standard form, minimize cx s.t. Ax = b x  0, use  Tableau(A, b, c).\n\nIf the LP is in canonical form, minimize cx subject to Ax  b x  0,  use Tableau(A, b, c, false).\n\n\n\n\n\n","category":"type"},{"location":"api/#SimplexTableaux.basic_vector-Tuple{Tableau}","page":"API","title":"SimplexTableaux.basic_vector","text":"basic_vector(T::Tableau)\n\nReturn the basic vector for T. This is the vector in which all nonbasic variables are 0. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.big_M_solve!","page":"API","title":"SimplexTableaux.big_M_solve!","text":"big_M_solve!(T::Tableau, M::Int=100, verbose::Bool=true)\n\nSolve the LP T using the big-M method.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimplexTableaux.big_M_tableau","page":"API","title":"SimplexTableaux.big_M_tableau","text":"big_M_tableau(T::Tableau, M::Int=100)\n\nForm a new tableau from T by adding m artificial variables  and add the terms +M*x_i (for each artificial variable x_i) to the objective function. Then set the basis to the columns for the artifical variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimplexTableaux.check_basis-Tuple{Tableau, Vector{Int64}}","page":"API","title":"SimplexTableaux.check_basis","text":"check_basis(T::Tableau, vars::Vector{Int})::Bool\n\nSee if the list of column indices vars forms a basis (feasible or not) for T.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.dual-Tuple{Tableau}","page":"API","title":"SimplexTableaux.dual","text":"dual(T::Tableau)\n\nCreate a tableau that is dual to T. \n\nNote: The returned tableau is set up as a minimization problem so the value of the solved LP is negative the desired value.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.dual_basic_vector-Tuple{Tableau}","page":"API","title":"SimplexTableaux.dual_basic_vector","text":"dual_basic_vector(T::Tableau)\n\nReturn the dual basic vector for T.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.find_a_basis","page":"API","title":"SimplexTableaux.find_a_basis","text":"find_a_basis(T::Tableau, verbose::Bool=true)\n\nReturn a feasible basis for the LP in T or nothing if none exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimplexTableaux.find_all_bases-Tuple{Tableau}","page":"API","title":"SimplexTableaux.find_all_bases","text":"find_all_bases(T::Tableau)\n\nReturn a list of all feasible bases for T.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.find_pivot-Tuple{Tableau, Int64}","page":"API","title":"SimplexTableaux.find_pivot","text":"find_pivot(T::Tableau, j::Int)\n\nFind a valid pivot in column j. Returns (i,j) showing where to pivot.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.find_pivot-Tuple{Tableau}","page":"API","title":"SimplexTableaux.find_pivot","text":"find_pivot(T::Tableau)\n\nFind a valid pivot for T or return (0,0) if none exists. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.find_pivot_column-Tuple{Tableau}","page":"API","title":"SimplexTableaux.find_pivot_column","text":"find_pivot_column(T::Tableau)\n\nFind a column with the most negative reduced cost  (i.e., the most positive value in the top row of the tableau).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.get_Abc-Tuple{Tableau}","page":"API","title":"SimplexTableaux.get_Abc","text":"get_Abc(T::Tableau)\n\nReturns a 3-tuple containing copies of the matrix A and the vectors b and c used to create T.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.get_basis-Tuple{Tableau}","page":"API","title":"SimplexTableaux.get_basis","text":"get_basis(T::Tableau)\n\nReturn the current basis (indices of basic variables).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.header-Tuple{Tableau}","page":"API","title":"SimplexTableaux.header","text":"header(T::Tableau)\n\nReturn the header (negative reduced costs) of T.\n\nExample\n\nFor this Tableau\n\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │  -2 │  -4 │  -2 │  -1 │   1 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   2 │   1 │   0 │   9 │  -1 │   9 │\n│   Cons 2 │ 0 │   1 │   1 │  -1 │   5 │   1 │   7 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nheader(T) returns the vector [-2, -4, -2, -1, 1].\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.in_dual_feasible_state-Tuple{Tableau}","page":"API","title":"SimplexTableaux.in_dual_feasible_state","text":"in_dual_feasible_state(T::Tableau)::Bool\n\nDetermine if the header of T is entirely nonpositive. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.in_feasible_state-Tuple{Tableau}","page":"API","title":"SimplexTableaux.in_feasible_state","text":"in_feasible_state(T::Tableau)::Bool\n\nReturn true is the current state of T is at a feasible vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.in_optimal_state-Tuple{Tableau}","page":"API","title":"SimplexTableaux.in_optimal_state","text":"in_optimal_state(T::Tableau)::Bool\n\nDetermine if T has been pivoted to a global minimum state.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.infer_basis!-Tuple{Tableau, Vector}","page":"API","title":"SimplexTableaux.infer_basis!","text":"infer_basis!(T::Tableau, x::Vector)\n\nWhen x is a basic feasbile vector for T, determine a basis  of columns to that effect.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.infer_basis!-Tuple{Tableau}","page":"API","title":"SimplexTableaux.infer_basis!","text":"infer_basis!(T::Tableau)\n\nFind the columns that form an elementary basis in T and assign that basis to T\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.is_canonical-Tuple{Tableau}","page":"API","title":"SimplexTableaux.is_canonical","text":"is_canonical(T::Tableau)::Bool\n\nReturn true if T was created from a canonical LP  and return false if it was created from a standard LP.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.is_infeasible-Tuple{Tableau}","page":"API","title":"SimplexTableaux.is_infeasible","text":"is_infeasible(T::Tableau)::Bool\n\nReturn true if the tableau represents an infeasible linear program (i.e., the  feasible region is empty).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.is_unbounded-Tuple{Tableau}","page":"API","title":"SimplexTableaux.is_unbounded","text":"is_unbounded(T::Tableau)::Bool\n\nReturn true is the linear program is unbounded (below).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.lp_solve","page":"API","title":"SimplexTableaux.lp_solve","text":"lp_solve(T::Tableau, verbose::Bool=true)\n\nUse a standard linear programming solver [HiGHS by defaut] to find the optimal solution to the LP in T. Returns the values of the variables. \n\nWith verbose set to true [default], the value of the objective function is printed. Set verbose to false to supress this. \n\n\n\n\n\n","category":"function"},{"location":"api/#SimplexTableaux.make_canonical-Tuple{Tableau}","page":"API","title":"SimplexTableaux.make_canonical","text":"make_canonical(T::Tableau)\n\nConvert a Tableau for a standard form LP into a new, equivalent Tableau in canonical form. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.make_standard-Tuple{Tableau}","page":"API","title":"SimplexTableaux.make_standard","text":"make_standard(T::Tableau)\n\nConvert a Tableau for a canonical LP into a new, equivalent Tableau in standard form. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.phase_one_tableau-Tuple{Tableau}","page":"API","title":"SimplexTableaux.phase_one_tableau","text":"phase_one_tableau(T::Tableau)\n\nCreate a tableau with additional slack variables from which it is  easy to extract a basis for T or determine that T is infeasible. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.pivot!-Tuple{Tableau, Int64, Int64}","page":"API","title":"SimplexTableaux.pivot!","text":"pivot!(T::Tableau, i::Int, j::Int)\n\nModify T by doing a pivot operation at constraint i  and variable x_j.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.ratios-Tuple{Tableau, Int64}","page":"API","title":"SimplexTableaux.ratios","text":"ratios(T::Tableau, col::Int)\n\nDisplay a table for determining a valid pivot for T in column col.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.restore!-Tuple{Tableau}","page":"API","title":"SimplexTableaux.restore!","text":"restore!(T::Tableau)\n\nRestore a Tableau based on the original data used to create it. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.rhs-Tuple{Tableau}","page":"API","title":"SimplexTableaux.rhs","text":"rhs(T::Tableau)\n\nReturn the right-hand column of the T. \n\nExample\n\nFor this Tableau\n\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │  -2 │  -4 │  -2 │  -1 │   1 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   2 │   1 │   0 │   9 │  -1 │   9 │\n│   Cons 2 │ 0 │   1 │   1 │  -1 │   5 │   1 │   7 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nrhs(T) returns the vector [9,7].\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.scale_row!-Tuple{Tableau, Int64, Union{Integer, Rational}}","page":"API","title":"SimplexTableaux.scale_row!","text":"scale_row!(T::Tableau, i::Int, m::_Exact)\n\nModify T by multiplying row i (the i-th constraint) by m. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.set_basis!-Tuple{Tableau, Vector{Int64}}","page":"API","title":"SimplexTableaux.set_basis!","text":"set_basis!(T::Tableau, vars::Vector{Int})\n\nPivot T so that the variables specified in vars are the basic variables. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.set_basis!-Tuple{Tableau}","page":"API","title":"SimplexTableaux.set_basis!","text":"set_basis!(T::Tableau)\n\nInvoke find_a_basis(T) and use the result to establish a basis for T. Silently fail if no basis is found. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.simplex_solve!","page":"API","title":"SimplexTableaux.simplex_solve!","text":"simplex_solve!(T::Tableau, verbose::Bool=true)\n\nSolve T using the simplex method. \n\n\n\n\n\n","category":"function"},{"location":"api/#SimplexTableaux.status-Tuple{Tableau}","page":"API","title":"SimplexTableaux.status","text":"status(T::Tableau)::Symbol\n\nReturn an indicator for the status of the tableau T being one of:\n\n:no_basis – no basis has been established for this tableau\n:feasible – the tableau is in a feasible state, but not optimal (rhs is nonnegative).\n:infeasible – the tableau is in an infeasible state (rhs contains negative values).\n:optimal – the tableau has reached a global minimization point.\n:unbounded – no pivots are possible; objective function can be arbitrarily negative.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.swap_rows!-Tuple{Tableau, Int64, Int64}","page":"API","title":"SimplexTableaux.swap_rows!","text":"swap_rows!(T::Tableau, i::Int, j::Int)\n\nSwap constraint rows i and j in the tableau T.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.value-Tuple{Tableau, Vector}","page":"API","title":"SimplexTableaux.value","text":"value(T::Tableau, x::Vector)\n\nReturn the value of the LP in T at the point x.\n\nThis can also be invoked as T(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.value-Tuple{Tableau}","page":"API","title":"SimplexTableaux.value","text":"value(T::Tableau)\n\nReturn the value of the LP at the current basic vector. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.verbose_pivot!-Tuple{Tableau, Int64, Int64}","page":"API","title":"SimplexTableaux.verbose_pivot!","text":"verbose_pivot!(T::Tableau, i::Int, j::Int)\n\nPerform pivot!(T,i,j) but narrate the process starting with scaling row i and then adding multiples of row i to the other rows of the tableau to clear column j.\n\n\n\n\n\n","category":"method"},{"location":"dual/#Duality","page":"Duality","title":"Duality","text":"","category":"section"},{"location":"dual/#Mathematical-Background","page":"Duality","title":"Mathematical Background","text":"Minimization linear programs can be (sort-of metaphorically speaking) transposed into maximization problems by forming their duals.\n\nA canonical linear program is of the form min c^T x subject to Ax ge b, xge0. \n\nThe dual of this LP is max b^T y such that A^Ty le b, yge0. \n\nA standard linear program is of the form min c^T x subject to Ax = b, x ge 0. The dual of this LP is max b^T y subject to A^T y le c (with no other restriction on y).","category":"section"},{"location":"dual/#Canonical-Dual","page":"Duality","title":"Canonical Dual","text":"The tableaux in this SimplexTableaux module are assumed to be for minimization problems.  Canonical LPs are are converted to standard form using slack variables.  Given a canonical LP (as described just above), the equivalent standard form LP looks like this: min c^Tx + 0^Ts subject to Ax - Is = b, xge0, and sge0. \n\nFor example, suppose A= left beginarrayccc 3  2  1 \n2  0  5 \nendarray right, b = left beginarrayc 5 \n2 \nendarray right, and  c = left beginarrayc 1 \n2 \n3 \nendarray right. The tableaux created by these instructions\n\nA = [3 2 1; 2 0 5]\nb = [5, 2]\nc = [1, 2, 3]\nT = Tableau(A, b, c, false)\n\nis this\n\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │  -1 │  -2 │  -3 │   0 │   0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   3 │   2 │   1 │  -1 │   0 │   5 │\n│   Cons 2 │ 0 │   2 │   0 │   5 │   0 │  -1 │   2 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nNote the addition of slack variables x_4 and x_5. \n\nThe dual LP involves a maximization and le-inequalities. To put this into a form suitable for this module, we replace max b^T y with min -b^Ty and we replace A^Ty le c with -A^Ty ge c. This is now a minimization problem in canonical form that needs to be converted to standard form before processing by the Simplex Method. \n\nThe dual function performs exactly these transformations to yield this:\n\njulia> dT = dual(T)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │   5 │   2 │   0 │   0 │   0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │  -3 │  -2 │  -1 │   0 │   0 │  -1 │\n│   Cons 2 │ 0 │  -2 │   0 │   0 │  -1 │   0 │  -2 │\n│   Cons 3 │ 0 │  -1 │  -5 │   0 │   0 │  -1 │  -3 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nRunning simplex_solve! on T and dT give these tableaux:\n\n┌──────────┬───┬─────┬──────┬───────┬──────┬─────┬─────┐\n│          │ z │ x_1 │  x_2 │   x_3 │  x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │   0 │ -4/3 │  -8/3 │ -1/3 │   0 │ 5/3 │\n├──────────┼───┼─────┼──────┼───────┼──────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │  2/3 │   1/3 │ -1/3 │   0 │ 5/3 │\n│   Cons 2 │ 0 │   0 │  4/3 │ -13/3 │ -2/3 │   1 │ 4/3 │\n└──────────┴───┴─────┴──────┴───────┴──────┴─────┴─────┘\n\nand\n\n┌──────────┬───┬─────┬──────┬──────┬─────┬─────┬──────┐\n│          │ z │ x_1 │  x_2 │  x_3 │ x_4 │ x_5 │  RHS │\n│ Obj Func │ 1 │   0 │ -4/3 │ -5/3 │   0 │   0 │ -5/3 │\n├──────────┼───┼─────┼──────┼──────┼─────┼─────┼──────┤\n│   Cons 1 │ 0 │   1 │  2/3 │  1/3 │   0 │   0 │  1/3 │\n│   Cons 2 │ 0 │   0 │ -4/3 │ -2/3 │   1 │   0 │  4/3 │\n│   Cons 3 │ 0 │   0 │ 13/3 │ -1/3 │   0 │   1 │  8/3 │\n└──────────┴───┴─────┴──────┴──────┴─────┴─────┴──────┘\n\nNote that the opitmum value achieved for dT is -5/3 because we replaced the function b^Ty with -b^Ty. Hence, the maximum value of the actualy dual linear program is 5/3 (the same as the original LP).","category":"section"},{"location":"dual/#Standard-Dual","page":"Duality","title":"Standard Dual","text":"The dual of min c^Tx s.t. Ax=b, xge0 is max b^Ty s.t. A^Tyle c. To put this into standard form requires these modifications:\n\nReplace max b^T y with min -b^Ty.\nReplace y with w-w where wge0 and wge0. \nReplace A^Ty le c with -A^Ty ge -c, or more expansively -A^T(w-w)ge c.\n\nFor example, suppose A = left beginarrayrrrrr 2  0  1  1  3 \n4  1  0  2  4 \n3  1  -1  2  2 \nendarray right, b = left beginarrayr 8 \n13 \n8 \nendarray right, and c = left beginarrayr 2 \n2 \n-1 \n-3 \n-2 \nendarray right. \n\nThe tableau is created by these instructions:\n\nA = [2 0 1 1 3; 4 1 0 2 4; 3 1 -1 2 2]\nb = [8; 13; 8]\nc = [2; 2; -1; -3; -2]\nT = Tableau(A, b, c, false)\n\nis this\n\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │  -2 │  -2 │   1 │   3 │   2 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   2 │   0 │   1 │   1 │   3 │   8 │\n│   Cons 2 │ 0 │   4 │   1 │   0 │   2 │   4 │  13 │\n│   Cons 3 │ 0 │   3 │   1 │  -1 │   2 │   2 │   8 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nWe create the dual:\n\njulia> dT = dual(T)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──────┬──────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ x_7 │ x_8 │ x_9 │ x_10 │ x_11 │ RHS │\n│ Obj Func │ 1 │   8 │  13 │   8 │  -8 │ -13 │  -8 │   0 │   0 │   0 │    0 │    0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼──────┼──────┼─────┤\n│   Cons 1 │ 0 │  -2 │  -4 │  -3 │   2 │   4 │   3 │  -1 │   0 │   0 │    0 │    0 │  -2 │\n│   Cons 2 │ 0 │   0 │  -1 │  -1 │   0 │   1 │   1 │   0 │  -1 │   0 │    0 │    0 │  -2 │\n│   Cons 3 │ 0 │  -1 │   0 │   1 │   1 │   0 │  -1 │   0 │   0 │  -1 │    0 │    0 │   1 │\n│   Cons 4 │ 0 │  -1 │  -2 │  -2 │   1 │   2 │   2 │   0 │   0 │   0 │   -1 │    0 │   3 │\n│   Cons 5 │ 0 │  -3 │  -4 │  -2 │   3 │   4 │   2 │   0 │   0 │   0 │    0 │   -1 │   2 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──────┴──────┴─────┘\n\nPlease note that x_7 through x_10 are slack variables.\n\nSolving these with simplex_solve! gives the following results for T and dT:\n\n┌──────────┬───┬──────┬─────┬──────┬─────┬─────┬──────┐\n│          │ z │  x_1 │ x_2 │  x_3 │ x_4 │ x_5 │  RHS │\n│ Obj Func │ 1 │ -5/2 │   0 │ -1/2 │   0 │   0 │ -5/2 │\n├──────────┼───┼──────┼─────┼──────┼─────┼─────┼──────┤\n│   Cons 1 │ 0 │  1/2 │   0 │ -1/2 │   1 │   0 │  1/2 │\n│   Cons 2 │ 0 │    1 │   1 │   -1 │   0 │   0 │    2 │\n│   Cons 3 │ 0 │  1/2 │   0 │  1/2 │   0 │   1 │  5/2 │\n└──────────┴───┴──────┴─────┴──────┴─────┴─────┴──────┘\n\nand\n\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──────┬──────┬──────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ x_7 │ x_8 │ x_9 │ x_10 │ x_11 │  RHS │\n│ Obj Func │ 1 │   0 │   0 │   0 │   0 │   0 │   0 │   0 │  -2 │   0 │ -1/2 │ -5/2 │  5/2 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼──────┼──────┼──────┤\n│   Cons 1 │ 0 │   1 │   0 │   0 │  -1 │   0 │   0 │   0 │   2 │   0 │   -1 │    0 │    7 │\n│   Cons 2 │ 0 │   0 │   0 │   1 │   0 │   0 │  -1 │   0 │   1 │   0 │ -3/2 │  1/2 │ 11/2 │\n│   Cons 3 │ 0 │   0 │  -1 │   0 │   0 │   1 │   0 │   0 │   2 │   0 │ -3/2 │  1/2 │ 15/2 │\n│   Cons 4 │ 0 │   0 │   0 │   0 │   0 │   0 │   0 │   1 │  -1 │   0 │ -1/2 │ -1/2 │  5/2 │\n│   Cons 5 │ 0 │   0 │   0 │   0 │   0 │   0 │   0 │   0 │   1 │   1 │  1/2 │ -1/2 │  1/2 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──────┴──────┴──────┘\n\nAs with canonical duals, the final objective value for dT is negative the desired maximum value for the actual dual. \n\nERRORS HERE!!\n\nThe final basic vector for dT is  left beginarrayr 0 \n152 \n0 \n7 \n0 \n112 \nendarray right giving w = left beginarrayr 0 \n152 \n0 \nendarray right and  w =left beginarrayr 7 \n0 \n112 \nendarray right. Therefore y=w-w= left beginarrayr 7 \n0 \n112 \nendarray right. This yields y= w-w = left beginarrayr -7 \n152 \n-112 \nendarray right.\n\nCheck that A^T y= left beginarrayr -12 \n2 \n-32 \n-3 \n-2 \nendarray right which is, term by term, less than or equal to c = left beginarrayr 2 \n2 \n-1 \n-3 \n-2 \nendarray right and that b^T y = -52. ","category":"section"},{"location":"other/#Other-Features","page":"Other Functions","title":"Other Features","text":"","category":"section"},{"location":"other/#Status-Functions","page":"Other Functions","title":"Status Functions","text":"The status function returns a symbol indicating the state of the tableau, T. The result  of status(T) is one of the following:\n\n:no_basis – no basis has been established for this tableau.\n:feasible – the tableau is in a feasible state, but not optimal (rhs is nonnegative).\n:infeasible – the tableau is in an infeasible state (rhs contains negative values). \n:optimal – the tableau has reached a global minimization point. This supercedes :feasible. \n:unbounded – the tableau has reached a feasible state, but there are no pivots; the objective function value can be arbitrarily negative. This supercedes :feasible.\n\nThese functions are superfluous but may be convenient: \n\nin_feasible_state(T) returns true if the current basic vector is in the feasible region (including if at optimality).\nin_optimal_state(T) returns true if the tableau has reached an optimal (minimal) state.","category":"section"},{"location":"other/#Form-Swapping","page":"Other Functions","title":"Form Swapping","text":"The functions make_standard and make_canonical convert a Tableau from standard to canonical, and from canonical to standard, respectively.  A new Tableau is returned unless the input Tableau is already in the desired form. \n\nmake_canonical adds slack variables to create a new Tableau that is in standard form and has the same solution.\nmake_standard replaces each equality constraint of the form ax=b with a pair of inequality constraints ax≥b and -ax≥-b.","category":"section"},{"location":"other/#Miscellaneous-Functions","page":"Other Functions","title":"Miscellaneous Functions","text":"basic_vector(T) returns the vector in which the nonbasic variables have been set to zero. \ndual_basic_vector(T) returns the dual basic vector. \nheader(T) returns the top row of T (negative reduced costs). Does not include the 1 in column 0 nor the value in the last column. \nget_Abc(T) returns the original matrix A and the vectors b and c for the standard presentation of the linear program.\nget_basis(T) returns the column numbers of the current basis.\nis_infeasible(T) returns true if the linear program's feasible region is empty. \nis_unbounded(T) returns true if the linear program is unbounded (below).\nrhs(T) returns the righthand column of T (from row 1 onward – does not include the value in row 0).\nvalue(T) returns the objective function value of the current basic vector. \nvalue(T,x) returns the objective function value for the vector x. May also be invoked as T(x). ","category":"section"},{"location":"other/#Return-to-Start","page":"Other Functions","title":"Return to Start","text":"The function restore! returns the tableau to its state when it was constructed. \n\njulia> T\n┌──────────┬───┬─────┬─────┬────────┬─────┬─────────┬──────────┐\n│          │ z │ x_1 │ x_2 │    x_3 │ x_4 │     x_5 │      RHS │\n│ Obj Func │ 1 │   0 │   0 │ -25/47 │   0 │ -110/47 │ 13500/47 │\n├──────────┼───┼─────┼─────┼────────┼─────┼─────────┼──────────┤\n│   Cons 1 │ 0 │   1 │   0 │   1/47 │   0 │   -5/47 │   400/47 │\n│   Cons 2 │ 0 │   0 │   0 │ -25/47 │   1 │  -16/47 │  -600/47 │\n│   Cons 3 │ 0 │   0 │   1 │  -5/47 │   0 │    3/94 │   350/47 │\n└──────────┴───┴─────┴─────┴────────┴─────┴─────────┴──────────┘\n\n\njulia> restore!(T)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │ -25 │ -10 │   0 │   0 │   0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   3 │  10 │  -1 │   0 │   0 │ 100 │\n│   Cons 2 │ 0 │   5 │   6 │   0 │  -1 │   0 │ 100 │\n│   Cons 3 │ 0 │  10 │   2 │   0 │   0 │  -1 │ 100 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘","category":"section"},{"location":"other/#LaTeX-Output","page":"Other Functions","title":"LaTeX Output","text":"Using LatexPrint users can get the  code for pasting into a LaTeX document.\n\njulia> using LatexPrint\n\njulia> T\n┌──────────┬───┬───────┬─────┬───────┬─────┬──────┬──────┐\n│          │ z │   x_1 │ x_2 │   x_3 │ x_4 │  x_5 │  RHS │\n│ Obj Func │ 1 │ -11/4 │   0 │ -43/4 │   0 │ 29/2 │ 37/2 │\n├──────────┼───┼───────┼─────┼───────┼─────┼──────┼──────┤\n│   Cons 1 │ 0 │  -1/4 │   1 │  -9/4 │   0 │  7/2 │  9/2 │\n│   Cons 2 │ 0 │   1/4 │   0 │   1/4 │   1 │ -1/2 │  1/2 │\n└──────────┴───┴───────┴─────┴───────┴─────┴──────┴──────┘\n\njulia> set_slash(); set_align('r')   # see LatexPrint documentation\n\njulia> lap(T)\n\\begin{tabular}{|r|rrrrr|r|}\\hline \n{\\large\\strut}$z$ &$x_{1}$ & $x_{2}$ & $x_{3}$ & $x_{4}$ & $x_{5}$ & RHS \\\\\n{\\large\\strut}$1$ & $-11/4$ & $0$ & $-43/4$ & $0$ & $29/2$ & $37/2$\\\\\n\\hline \n{\\large\\strut}$0$ & $-1/4$ & $1$ & $-9/4$ & $0$ & $7/2$ & $9/2$\\\\\n{\\large\\strut}$0$ & $1/4$ & $0$ & $1/4$ & $1$ & $-1/2$ & $1/2$\\\\\n\\hline \n\\end{tabular}\n\nHere is the LaTeX output:\n\n(Image: )","category":"section"},{"location":"other/#Other-Public-Functions","page":"Other Functions","title":"Other Public Functions","text":"Presently, these functions are exported in SimplexTableaux but might be hidden in future releases.  They are not likely to be useful to the users of this module.  See the doc strings for more information:\n\nbig_M_tableau\ncheck_basis\nfind_pivot_column\ninfer_basis!","category":"section"},{"location":"#SimplexTableaux","page":"Overview","title":"SimplexTableaux","text":"This module demonstrates how to solve linear programs using the Simplex Method.\n\nIn particular, it can be used to solve feasible optimization problems of the form  of the form min c^T x subject to Ax = b and x ge 0 (standard form) as well as  min c^T x subject to Ax  b and x ge 0 (canonical form)\n\nSee the Tutorial for a thorough introduction to this module.\n\nThis is a demonstration project for illustrating the Simplex Method and for solving small linear programs.  All arithmetic is exact (using arbitrary precision rational numbers).\n\nThis module serves as a supplement to the (currently under construction) textbook Mathematical Optimization: From Knowledge to Wisdom.","category":"section"},{"location":"#Feedback-please","page":"Overview","title":"Feedback please","text":"I am hoping this module is useful for those learning the Simplex Method.  Whether you are a student or an instructor, I would appreciate your feedback. ","category":"section"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"This is a step-by-step guide for solving linear programs using the SimplexTableau module.","category":"section"},{"location":"tutorial/#Setting-Up","page":"Tutorial","title":"Setting Up","text":"This module enables the user to solve linear program problems in one of the following two forms:\n\nStandard: min c^T  x subject to A x = b x  0. Use: Tableau(A,b,c) or Tableau(A,b,c,false). \nCanonical: min c^T  x subject to A x  b x  0. Use: Tableau(A,b,c,true).\n\nHere, A is an m times n-matrix, b is an m-vector, and c is an n-vector. \n\nOnly minimization problems are supported. \n\nEvery number entered into a Tableau must be an  Integer  or a Rational.  Internally, all numbers are converted to Rational{BigInt} type. This module does not support linear programs with floating point data.","category":"section"},{"location":"tutorial/#Example:-Standard-form-linear-program","page":"Tutorial","title":"Example: Standard form linear program","text":"Let  A=left beginarrayrrrrrr 1  8  -2  8  6  -1 \n2  6  2  9  2  1 \n6  3  5  9  7  1 \nendarray right,  b= left beginarrayr -2 \n4 \n9 \nendarray right, and c = left beginarrayr 0 \n3 \n3 \n-1 \n2 \n-4 \nendarray right. \n\nHere is how to set up the standard LP min c^T x s.t. Ax=bxge0:\n\njulia> A = [1 8 -2 8 6 -1; 2 6 2 9 2 1; 6 3 5 9 7 1];\n\njulia> b = [-2, 4, 9];\n\njulia> c = [0, 3, 3, -1, 2, -4];\n\njulia> T = Tableau(A, b, c)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │\n│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │\n│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nWritten as a (partitioned) matrix, this tableau looks like this:\n\nleft\nbeginarrayrrrrrrrr\n1  0  -3  -3  1  -2  4  0  hline\n0  1  8  -2  8  6  -1  -2 \n0  2  6  2  9  2  1  4 \n0  6  3  5  9  7  1  9 \nendarray\nright\n\nThe top (header) row represents the objective function we wish to minimize: z = 0x_1 + 3x_2 + 3x_3 - x_4 + 2x_5 - 4x_6. It is rearranged to appear in the form  z - 0x_1 - 3x_2 - 3x_3 + x_4 - 2x_5 + 4x_6 = 0. \n\nThe next three rows are the constraints from A x = b. For example, the first constraint is x_1 + 8x_2 - 2x_3 + 8x_4 + 6x_5 - x_6 = -2.","category":"section"},{"location":"tutorial/#Example:-Canonical-form-linear-program","page":"Tutorial","title":"Example: Canonical form linear program","text":"Let A=left beginarrayrrrr 7  5  2  9 \n5  9  5  5 \nendarray right,  b=left beginarrayr 2 \n5 \nendarray right  and c=left beginarrayr 7 \n6 \n3 \n4 \nendarray right. \n\nHere is how to set up the canonical LP min c^T x s.t. Axge b xge0:\n\njulia> A = [7 5 2 9; 5 9 5 5];\n\njulia> b = [2, 5];\n\njulia> c = [7, 6, 3, 4];\n\njulia> T = Tableau(A, b, c, true)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │  -7 │  -6 │  -3 │  -4 │   0 │   0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   7 │   5 │   2 │   9 │  -1 │   0 │   2 │\n│   Cons 2 │ 0 │   5 │   9 │   5 │   5 │   0 │  -1 │   5 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nNote that x_5 and x_6 are added as slack variables. Therefore the first constraint is 7x_1 + 5x_2 +2 x_3 +9x_4 - x_5=2 which is equivalent to 7x_1 + 5x_2 +2 x_3 +9x_4 ge 2. With these extra variables, the LP is now in standard form.\n\nThe objective function is z = 7x_1 + 6x_2 + 3x_3 + 4x_4 that is encoded in the tableau  as z-7x_1 -6x_2 -3x_3 -4x_4=0. ","category":"section"},{"location":"tutorial/#Pivoting","page":"Tutorial","title":"Pivoting","text":"Pivoting is a fundamental operation in linear algebra that is used extensively in the Simplex Method. A pivot on element a_ij of a matrix begins by multiplying row i by 1a_ij. This leaves a 1 in position ij. Then multiples of row i are added to the other rows so that all the other entries in column j are now 0. \n\nFor example, suppose we wish to pivot on the 2 in this matrix:\n\nleft\nbeginarrayrrrrrrrr\n1  -7  -6  -3  -4  0  0  0  hline\n0  7  5  fbox2  9  -1  0  2 \n0  5  9  5  5  0  -1  5 \nendarray\nright\n\nThe main body of the matrix lies below the header row and between the vertical dividers. This is considered to be the 13-entry of the matrix: this corresponds to the constraint 1 in the column of x_3. \n\nFirst we multiply row 1 through by 12:\n\nleft\nbeginarrayrrrrrrrr\n1  -7  -6  -3  -4  0  0  0  hline\n0  72  52  1  92  -12  0  1 \n0  5  9  5  5  0  -1  5 \nendarray\nright\n\nThen we add 3 times the first row to the header (row 0) and -5 times the first row to the second row:\n\nleft\nbeginarrayrrrrrrrr\n1  72  32  0  192  -32  0  3  hline\n0  72  52  1  92  -12  0  1 \n0  -252  -72  0  -352  52  -1  0 \nendarray\nright\n\nIn the SimplexTableau module, this operation is accomplished with the pivot! function:\n\njulia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │  -7 │  -6 │  -3 │  -4 │   0 │   0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   7 │   5 │   2 │   9 │  -1 │   0 │   2 │\n│   Cons 2 │ 0 │   5 │   9 │   5 │   5 │   0 │  -1 │   5 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> pivot!(T,1,3)\n┌──────────┬───┬───────┬──────┬─────┬───────┬──────┬─────┬─────┐\n│          │ z │   x_1 │  x_2 │ x_3 │   x_4 │  x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   7/2 │  3/2 │   0 │  19/2 │ -3/2 │   0 │   3 │\n├──────────┼───┼───────┼──────┼─────┼───────┼──────┼─────┼─────┤\n│   Cons 1 │ 0 │   7/2 │  5/2 │   1 │   9/2 │ -1/2 │   0 │   1 │\n│   Cons 2 │ 0 │ -25/2 │ -7/2 │   0 │ -35/2 │  5/2 │  -1 │   0 │\n└──────────┴───┴───────┴──────┴─────┴───────┴──────┴─────┴─────┘","category":"section"},{"location":"tutorial/#Verbose-pivoting","page":"Tutorial","title":"Verbose pivoting","text":"The function verbose_pivot! does the same calculations as pivot! but narrates the entire process.\n\njulia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │  -2 │  -2 │   1 │   3 │   2 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   2 │   0 │   1 │   1 │   3 │   8 │\n│   Cons 2 │ 0 │   4 │   1 │   0 │   2 │   4 │  13 │\n│   Cons 3 │ 0 │   3 │   1 │  -1 │   2 │   2 │   8 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> verbose_pivot!(T,1,1)\nPivoting on the 2 at entry (1,1) of this tableau.\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │  -2 │  -2 │   1 │   3 │   2 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   2 │   0 │   1 │   1 │   3 │   8 │\n│   Cons 2 │ 0 │   4 │   1 │   0 │   2 │   4 │  13 │\n│   Cons 3 │ 0 │   3 │   1 │  -1 │   2 │   2 │   8 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nScaling row 1 by 1/2.\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │  -2 │  -2 │   1 │   3 │   2 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   0 │ 1/2 │ 1/2 │ 3/2 │   4 │\n│   Cons 2 │ 0 │   4 │   1 │   0 │   2 │   4 │  13 │\n│   Cons 3 │ 0 │   3 │   1 │  -1 │   2 │   2 │   8 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nAdding 2 times row 1 to top row.\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │   0 │  -2 │   2 │   4 │   5 │   8 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   0 │ 1/2 │ 1/2 │ 3/2 │   4 │\n│   Cons 2 │ 0 │   4 │   1 │   0 │   2 │   4 │  13 │\n│   Cons 3 │ 0 │   3 │   1 │  -1 │   2 │   2 │   8 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nAdding -4 times row 1 to row 2.\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │   0 │  -2 │   2 │   4 │   5 │   8 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   0 │ 1/2 │ 1/2 │ 3/2 │   4 │\n│   Cons 2 │ 0 │   0 │   1 │  -2 │   0 │  -2 │  -3 │\n│   Cons 3 │ 0 │   3 │   1 │  -1 │   2 │   2 │   8 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nAdding -3 times row 1 to row 3.\n┌──────────┬───┬─────┬─────┬──────┬─────┬──────┬─────┐\n│          │ z │ x_1 │ x_2 │  x_3 │ x_4 │  x_5 │ RHS │\n│ Obj Func │ 1 │   0 │  -2 │    2 │   4 │    5 │   8 │\n├──────────┼───┼─────┼─────┼──────┼─────┼──────┼─────┤\n│   Cons 1 │ 0 │   1 │   0 │  1/2 │ 1/2 │  3/2 │   4 │\n│   Cons 2 │ 0 │   0 │   1 │   -2 │   0 │   -2 │  -3 │\n│   Cons 3 │ 0 │   0 │   1 │ -5/2 │ 1/2 │ -5/2 │  -4 │\n└──────────┴───┴─────┴─────┴──────┴─────┴──────┴─────┘","category":"section"},{"location":"tutorial/#Bases","page":"Tutorial","title":"Bases","text":"The Simplex Method begins by finding a set of m columns (where m is the number of  constraints) that are linearly independent. We pivot on elements of those columns to  transform them into standard basis vectors. That is, in each of those columns there is a single 1  all other elements of that column are 0 (including in the header).\n\nIn the example we just considered, we see that pivoting on the -1 in the (26) position  will result in columns 3 and 6 forming a basis, and so those columns are called basic. \n\njulia> T\n┌──────────┬───┬───────┬──────┬─────┬───────┬──────┬─────┬─────┐\n│          │ z │   x_1 │  x_2 │ x_3 │   x_4 │  x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   7/2 │  3/2 │   0 │  19/2 │ -3/2 │   0 │   3 │\n├──────────┼───┼───────┼──────┼─────┼───────┼──────┼─────┼─────┤\n│   Cons 1 │ 0 │   7/2 │  5/2 │   1 │   9/2 │ -1/2 │   0 │   1 │\n│   Cons 2 │ 0 │ -25/2 │ -7/2 │   0 │ -35/2 │  5/2 │  -1 │   0 │\n└──────────┴───┴───────┴──────┴─────┴───────┴──────┴─────┴─────┘\n\njulia> pivot!(T,2,6)\n┌──────────┬───┬──────┬─────┬─────┬──────┬──────┬─────┬─────┐\n│          │ z │  x_1 │ x_2 │ x_3 │  x_4 │  x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │  7/2 │ 3/2 │   0 │ 19/2 │ -3/2 │   0 │   3 │\n├──────────┼───┼──────┼─────┼─────┼──────┼──────┼─────┼─────┤\n│   Cons 1 │ 0 │  7/2 │ 5/2 │   1 │  9/2 │ -1/2 │   0 │   1 │\n│   Cons 2 │ 0 │ 25/2 │ 7/2 │   0 │ 35/2 │ -5/2 │   1 │   0 │\n└──────────┴───┴──────┴─────┴─────┴──────┴──────┴─────┴─────┘\n\njulia> get_basis(T)\n2-element Vector{Int64}:\n 3\n 6\n\nThe get_basis function returns the current basis. If the tableau does not have a basis, a vector of all zeros is returned. \n\nOn the computer display, the labels of the basic columns are green. \n\n(Image: )","category":"section"},{"location":"tutorial/#Setting-a-basis","page":"Tutorial","title":"Setting a basis","text":"The function set_basis! is used to select columns to be a basis. This is invoked as  set_basis(T, B) where B is a list of m indices specifying the columns to form a basis. \n\nFor example:\n\njulia> set_basis!(T,[2,4])\n┌──────────┬───┬────────┬─────┬──────┬─────┬───────┬────────┬──────┐\n│          │ z │    x_1 │ x_2 │  x_3 │ x_4 │   x_5 │    x_6 │  RHS │\n│ Obj Func │ 1 │ -45/14 │   0 │  1/4 │   0 │ -3/28 │ -17/28 │ 13/4 │\n├──────────┼───┼────────┼─────┼──────┼─────┼───────┼────────┼──────┤\n│   Cons 1 │ 0 │   5/28 │   1 │  5/8 │   0 │  5/56 │  -9/56 │  5/8 │\n│   Cons 2 │ 0 │  19/28 │   0 │ -1/8 │   1 │ -9/56 │   5/56 │ -1/8 │\n└──────────┴───┴────────┴─────┴──────┴─────┴───────┴────────┴──────┘\n\nHowever, this basis is not suitable for the Simplex Algorithm because the RHS column contains negative numbers. In other words, 24  is an infeasible basis. On the other hand 36 yields a  feasible tableau.\n\njulia> set_basis!(T,[3,6])\n┌──────────┬───┬──────┬─────┬─────┬──────┬──────┬─────┬─────┐\n│          │ z │  x_1 │ x_2 │ x_3 │  x_4 │  x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │  7/2 │ 3/2 │   0 │ 19/2 │ -3/2 │   0 │   3 │\n├──────────┼───┼──────┼─────┼─────┼──────┼──────┼─────┼─────┤\n│   Cons 1 │ 0 │  7/2 │ 5/2 │   1 │  9/2 │ -1/2 │   0 │   1 │\n│   Cons 2 │ 0 │ 25/2 │ 7/2 │   0 │ 35/2 │ -5/2 │   1 │   0 │\n└──────────┴───┴──────┴─────┴─────┴──────┴──────┴─────┴─────┘","category":"section"},{"location":"tutorial/#Automatic-basis-selection","page":"Tutorial","title":"Automatic basis selection","text":"While any m linearly independent columns may be selected to form a basis, finding a set of columns that yield a feasible tableau can be difficult. In a later section of this tutorial we describe a method for finding a basis,  but we also provide tools to make this easy.\n\nThe function find_a_basis automatically finds a feasible basis. Combined with set_basis!  the resut is a tableau that has been pivoted to a feasible configuation. \n\njulia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │  -7 │  -6 │  -3 │  -4 │   0 │   0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   7 │   5 │   2 │   9 │  -1 │   0 │   2 │\n│   Cons 2 │ 0 │   5 │   9 │   5 │   5 │   0 │  -1 │   5 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> find_a_basis(T)\n2-element Vector{Int64}:\n 2\n 5\n\njulia> set_basis!(T,[2,5])\n┌──────────┬───┬───────┬─────┬─────┬───────┬─────┬──────┬──────┐\n│          │ z │   x_1 │ x_2 │ x_3 │   x_4 │ x_5 │  x_6 │  RHS │\n│ Obj Func │ 1 │ -11/3 │   0 │ 1/3 │  -2/3 │   0 │ -2/3 │ 10/3 │\n├──────────┼───┼───────┼─────┼─────┼───────┼─────┼──────┼──────┤\n│   Cons 1 │ 0 │   5/9 │   1 │ 5/9 │   5/9 │   0 │ -1/9 │  5/9 │\n│   Cons 2 │ 0 │ -38/9 │   0 │ 7/9 │ -56/9 │   1 │ -5/9 │  7/9 │\n└──────────┴───┴───────┴─────┴─────┴───────┴─────┴──────┴──────┘\n\nAlternatively, using set_basis!(T), without specifying a basis,   invokes find_a_basis to choose the basis for you. \n\nIf the tableau does not have a feasible basis, find_a_basis returns a vector of all zeros.\n\njulia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │  -3 │  -1 │  -5 │  -2 │  -5 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   3 │   2 │   2 │   2 │   3 │   4 │\n│   Cons 2 │ 0 │   4 │   4 │   3 │   5 │   2 │   2 │\n│   Cons 3 │ 0 │   1 │   2 │   4 │   2 │   1 │   1 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> find_a_basis(T)\n[ Info: No basis found.\n3-element Vector{Int64}:\n 0\n 0\n 0","category":"section"},{"location":"tutorial/#Listing-all-feasible-bases","page":"Tutorial","title":"Listing all feasible bases","text":"The function find_all_bases returns a list of all feasible bases for a tableau:\n\njulia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │\n│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │\n│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> find_all_bases(T)\n6-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 3, 4]\n [1, 3, 6]\n [2, 3, 5]\n [3, 4, 5]\n [3, 5, 6]\n\nThe find_all_bases function is highly inefficient and only suitable for small linear programs. ","category":"section"},{"location":"tutorial/#Simplex-Method","page":"Tutorial","title":"Simplex Method","text":"The Simplex Method finds the minimum objective value for a linear program, as well as the  vector at which that minimum is achieved. ","category":"section"},{"location":"tutorial/#Overview","page":"Tutorial","title":"Overview","text":"The steps in the Simplex Method are:\n\nSelect a feasible starting basis. (If there is no such basis, the LP is infeasible.)\nFind a column headed by a positive number. (If there are none, the LP has reached an optimal state.)\nForm the ratios between the righthand column and the positive members of the column selected in step 2. \nPivot on whichever entry in the selected column gives the lowest ratio. (If there are no positive numbers in the selected column, the LP is unbounded.)\nGo to step 2. ","category":"section"},{"location":"tutorial/#Manual-execution-of-the-Simplex-Algorithm","page":"Tutorial","title":"Manual execution of the Simplex Algorithm","text":"The first step is to find a first basis for a tableau T either:\n\nUse B = find_a_basis(T); set_basis!(T,B) or more simply\nset_basis!(T).\n\njulia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │\n│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │\n│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> set_basis!(T)\n┌──────────┬───┬─────────┬──────────┬─────┬─────┬─────┬──────────┬────────┐\n│          │ z │     x_1 │      x_2 │ x_3 │ x_4 │ x_5 │      x_6 │    RHS │\n│ Obj Func │ 1 │ 795/284 │ -931/142 │   0 │   0 │   0 │ 1265/284 │ 334/71 │\n├──────────┼───┼─────────┼──────────┼─────┼─────┼─────┼──────────┼────────┤\n│   Cons 1 │ 0 │ 187/284 │ -117/142 │   1 │   0 │   0 │   85/284 │ 110/71 │\n│   Cons 2 │ 0 │   -1/71 │    62/71 │   0 │   1 │   0 │     6/71 │   6/71 │\n│   Cons 3 │ 0 │ 115/284 │  -15/142 │   0 │   0 │   1 │  -51/284 │   5/71 │\n└──────────┴───┴─────────┴──────────┴─────┴─────┴─────┴──────────┴────────┘\n\nLater, we show how to find a first basis manually. See Finding a first basis later in this tutorial. \n\n\n\nNext we need to select a column in which to pivot. In this example, there are two columns headed by positive numbers: Column 1 is headed by 795/284 and column 6 is headed by 1265/284.\n\nIt is possible to use the function find_pivot(T) to select the element on which to pivot.\n\njulia> find_pivot(T)\n(2, 6)\n\nThis tells us to pivot at the (26)-entry of the tableau (where we see the value 671). \n\nWhile the find_pivot function suggested we pivot in column 6, we see that column 1 is also headed by a positive number, so we have the option to select a pivot there.  We can use the ratios functions to calculate the appropriate pivot for a user-selected column. \n\njulia> T\n┌──────────┬───┬─────────┬──────────┬─────┬─────┬─────┬──────────┬────────┐\n│          │ z │     x_1 │      x_2 │ x_3 │ x_4 │ x_5 │      x_6 │    RHS │\n│ Obj Func │ 1 │ 795/284 │ -931/142 │   0 │   0 │   0 │ 1265/284 │ 334/71 │\n├──────────┼───┼─────────┼──────────┼─────┼─────┼─────┼──────────┼────────┤\n│   Cons 1 │ 0 │ 187/284 │ -117/142 │   1 │   0 │   0 │   85/284 │ 110/71 │\n│   Cons 2 │ 0 │   -1/71 │    62/71 │   0 │   1 │   0 │     6/71 │   6/71 │\n│   Cons 3 │ 0 │ 115/284 │  -15/142 │   0 │   0 │   1 │  -51/284 │   5/71 │\n└──────────┴───┴─────────┴──────────┴─────┴─────┴─────┴──────────┴────────┘\n\n\njulia> ratios(T,1)\n        Ratios for column 1 headed by 795/284\n                Best pivot is in row 3\n┌────────────┬──────────┬────────┬───────┬───────────┐\n│ Constraint │ Column 1 │    RHS │ Ratio │   Decimal │\n├────────────┼──────────┼────────┼───────┼───────────┤\n│          1 │  187/284 │ 110/71 │ 40/17 │ 2.3529412 │\n│          2 │    -1/71 │   6/71 │   --- │       --- │\n│          3 │  115/284 │   5/71 │  4/23 │ 0.1739130 │\n└────────────┴──────────┴────────┴───────┴───────────┘\n\nThis analysis shows that if we decide to pivot in column 1, we should do so at the (31)-entry. Here is the result:\n\njulia> pivot!(T,3,1)\n┌──────────┬───┬─────┬─────────┬─────┬─────┬──────────┬─────────┬───────┐\n│          │ z │ x_1 │     x_2 │ x_3 │ x_4 │      x_5 │     x_6 │   RHS │\n│ Obj Func │ 1 │   0 │ -134/23 │   0 │   0 │  -159/23 │  131/23 │ 97/23 │\n├──────────┼───┼─────┼─────────┼─────┼─────┼──────────┼─────────┼───────┤\n│   Cons 1 │ 0 │   0 │  -15/23 │   1 │   0 │ -187/115 │  68/115 │ 33/23 │\n│   Cons 2 │ 0 │   0 │   20/23 │   0 │   1 │    4/115 │   9/115 │  2/23 │\n│   Cons 3 │ 0 │   1 │   -6/23 │   0 │   0 │  284/115 │ -51/115 │  4/23 │\n└──────────┴───┴─────┴─────────┴─────┴─────┴──────────┴─────────┴───────┘\n\nNow the column 6 is the only one headed by a positive number. We can use find_pivot(T) or use ratios to find the smallest ratio:\n\njulia> ratios(T,6)\n         Ratios for column 6 headed by 131/23\n                Best pivot is in row 2\n┌────────────┬──────────┬───────┬────────┬───────────┐\n│ Constraint │ Column 6 │   RHS │  Ratio │   Decimal │\n├────────────┼──────────┼───────┼────────┼───────────┤\n│          1 │   68/115 │ 33/23 │ 165/68 │ 2.4264706 │\n│          2 │    9/115 │  2/23 │   10/9 │ 1.1111111 │\n│          3 │  -51/115 │  4/23 │    --- │       --- │\n└────────────┴──────────┴───────┴────────┴───────────┘\n\nPivoting at (26):\n\njulia> pivot!(T,2,6)\n┌──────────┬───┬─────┬────────┬─────┬────────┬───────┬─────┬───────┐\n│          │ z │ x_1 │    x_2 │ x_3 │    x_4 │   x_5 │ x_6 │   RHS │\n│ Obj Func │ 1 │   0 │ -622/9 │   0 │ -655/9 │ -85/9 │   0 │ -19/9 │\n├──────────┼───┼─────┼────────┼─────┼────────┼───────┼─────┼───────┤\n│   Cons 1 │ 0 │   0 │  -65/9 │   1 │  -68/9 │ -17/9 │   0 │   7/9 │\n│   Cons 2 │ 0 │   0 │  100/9 │   0 │  115/9 │   4/9 │   1 │  10/9 │\n│   Cons 3 │ 0 │   1 │   14/3 │   0 │   17/3 │   8/3 │   0 │   2/3 │\n└──────────┴───┴─────┴────────┴─────┴────────┴───────┴─────┴───────┘\n\nThere are no positive entries in the top row signalling that the tableau has reached its optimal state. This is verified by the status function:\n\njulia> status(T)\n:optimal\n\nFinally, we get the minimum value and the vector that attains that value:\n\njulia> value(T)\n-19//9\n\njulia> basic_vector(T)\n6-element Vector{Rational}:\n  2//3\n   0\n  7//9\n   0\n   0\n 10//9","category":"section"},{"location":"tutorial/#Fully-automatic-execution-of-the-Simplex-Algorithm","page":"Tutorial","title":"Fully automatic execution of the Simplex Algorithm","text":"The simplex_solve! function does all the steps of the Simplex Method without requiring any interaction with the user. We return the tableau T to its original state with restore!(T) and then solve the LP using simplex_solver:\n\njulia> restore!(T)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │\n│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │\n│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\njulia> simplex_solve!(T)\n[ Info: Finding an initial basis.\nStarting basis found: [3, 4, 5]\nStarting tableau\n\n┌──────────┬───┬─────────┬──────────┬─────┬─────┬─────┬──────────┬────────┐\n│          │ z │     x_1 │      x_2 │ x_3 │ x_4 │ x_5 │      x_6 │    RHS │\n│ Obj Func │ 1 │ 795/284 │ -931/142 │   0 │   0 │   0 │ 1265/284 │ 334/71 │\n├──────────┼───┼─────────┼──────────┼─────┼─────┼─────┼──────────┼────────┤\n│   Cons 1 │ 0 │ 187/284 │ -117/142 │   1 │   0 │   0 │   85/284 │ 110/71 │\n│   Cons 2 │ 0 │   -1/71 │    62/71 │   0 │   1 │   0 │     6/71 │   6/71 │\n│   Cons 3 │ 0 │ 115/284 │  -15/142 │   0 │   0 │   1 │  -51/284 │   5/71 │\n└──────────┴───┴─────────┴──────────┴─────┴─────┴─────┴──────────┴────────┘\n\nPivot 1 at (2, 6)\n\n┌──────────┬───┬───────┬─────────┬─────┬──────────┬─────┬─────┬─────┐\n│          │ z │   x_1 │     x_2 │ x_3 │      x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │ 85/24 │ -631/12 │   0 │ -1265/24 │   0 │   0 │ 1/4 │\n├──────────┼───┼───────┼─────────┼─────┼──────────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │ 17/24 │  -47/12 │   1 │   -85/24 │   0 │   0 │ 5/4 │\n│   Cons 2 │ 0 │  -1/6 │    31/3 │   0 │     71/6 │   0 │   1 │   1 │\n│   Cons 3 │ 0 │   3/8 │     7/4 │   0 │     17/8 │   1 │   0 │ 1/4 │\n└──────────┴───┴───────┴─────────┴─────┴──────────┴─────┴─────┴─────┘\n\nPivot 2 at (3, 1)\n\n┌──────────┬───┬─────┬────────┬─────┬────────┬───────┬─────┬───────┐\n│          │ z │ x_1 │    x_2 │ x_3 │    x_4 │   x_5 │ x_6 │   RHS │\n│ Obj Func │ 1 │   0 │ -622/9 │   0 │ -655/9 │ -85/9 │   0 │ -19/9 │\n├──────────┼───┼─────┼────────┼─────┼────────┼───────┼─────┼───────┤\n│   Cons 1 │ 0 │   0 │  -65/9 │   1 │  -68/9 │ -17/9 │   0 │   7/9 │\n│   Cons 2 │ 0 │   0 │  100/9 │   0 │  115/9 │   4/9 │   1 │  10/9 │\n│   Cons 3 │ 0 │   1 │   14/3 │   0 │   17/3 │   8/3 │   0 │   2/3 │\n└──────────┴───┴─────┴────────┴─────┴────────┴───────┴─────┴───────┘\n\nOptimality reached. Pivot count = 2\nMinimal value = -19/9 = -2.111111111111111\n6-element Vector{Rational}:\n  2//3\n   0\n  7//9\n   0\n   0\n 10//9","category":"section"},{"location":"tutorial/#Numerically","page":"Tutorial","title":"Numerically","text":"The function lp_solve also solves linear programs but uses floating point rather than exact arithmetic. It uses the HiGHS solver to find the optimal solution: \n\njulia> lp_solve(T)\nMinimal objective value = -2.1111111111111183\n\n6-element Vector{Float64}:\n 0.6666666666666666\n 0.0\n 0.7777777777777776\n 0.0\n 0.0\n 1.1111111111111127","category":"section"},{"location":"tutorial/#Finding-a-First-Basis","page":"Tutorial","title":"Finding a First Basis","text":"Given a (standard form) linear program with n variables and m constraints, we form an  auxilliary LP as follows: \n\nCreate m additional variables, x_n+1 x_n+2ldotsx_n+m.\nIf a constraint has a negative right-hand side, multiply both sides by -1. This ensures that all constraints have a nonnegative right-hand side. \nAdd a +x_n+i term to the left-hand side of constraint i for i=12ldotsm. \nUse x_n+1 + x_n+2 + cdots + x_n+m as the objective function to be minimized.\n\nIn this new tableau, it is immediate that the new, auxilliary columns form a feasible basis. \n\nUse the function phase_one_tableau build this auxilliary tableau from the original:\n\njulia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │  # note the RHS of row 1 is negative\n│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │\n│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> TT = phase_one_tableau(T)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ x_7 │ x_8 │ x_9 │ RHS │\n│ Obj Func │ 1 │   7 │   1 │   9 │  10 │   3 │   3 │   0 │   0 │   0 │  15 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │  -1 │  -8 │   2 │  -8 │  -6 │   1 │   1 │   0 │   0 │   2 │ \n│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   0 │   1 │   0 │   4 │\n│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   0 │   0 │   1 │   9 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\njulia> get_basis(TT)\n3-element Vector{Int64}:\n 7\n 8\n 9\n\nWe now solve TT by the Simplex Method either manually or automatically:\n\njulia> simplex_solve!(TT, false);   # the false argument supresses the verbose output\n\njulia> TT\n┌──────────┬───┬─────────┬──────────┬─────┬─────┬─────┬─────────┬─────────┬─────────┬────────┬────────┐\n│          │ z │     x_1 │      x_2 │ x_3 │ x_4 │ x_5 │     x_6 │     x_7 │     x_8 │    x_9 │    RHS │\n│ Obj Func │ 1 │       0 │        0 │   0 │   0 │   0 │       0 │      -1 │      -1 │     -1 │      0 │\n├──────────┼───┼─────────┼──────────┼─────┼─────┼─────┼─────────┼─────────┼─────────┼────────┼────────┤\n│   Cons 1 │ 0 │ 187/284 │ -117/142 │   1 │   0 │   0 │  85/284 │  45/284 │   1/142 │ 19/142 │ 110/71 │\n│   Cons 2 │ 0 │   -1/71 │    62/71 │   0 │   1 │   0 │    6/71 │   -1/71 │   11/71 │  -4/71 │   6/71 │\n│   Cons 3 │ 0 │ 115/284 │  -15/142 │   0 │   0 │   1 │ -51/284 │ -27/284 │ -29/142 │ 17/142 │   5/71 │\n└──────────┴───┴─────────┴──────────┴─────┴─────┴─────┴─────────┴─────────┴─────────┴────────┴────────┘\n\njulia> value(TT)\n0//1\n\njulia> get_basis(TT)\n3-element Vector{Int64}:\n 3\n 4\n 5\n\nBecause the value of the final auxilliary tableau is zero, its basis is the starting basis for T.\n\nIf the final value for the auxilliary tableau is not zero, then the original tableau is infeasible. ","category":"section"}]
}
