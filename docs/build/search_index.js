var documenterSearchIndex = {"docs":
[{"location":"api/#Exported-SimplexTableaux-Functions-and-their-Docstrings","page":"API","title":"Exported  SimplexTableaux Functions and their Docstrings","text":"","category":"section"},{"location":"api/#SimplexTableaux.Tableau","page":"API","title":"SimplexTableaux.Tableau","text":"Tableau(A::Matrix, b::Vector, c::Vector)\n\nCreate a Tableau data structure for the canonical form  linear program  min c * x subject to A * x  b x  0.\n\nIf the LP is in standard form, min c x s.t. A * x = b x  0, use  Tableau(A, b, c, false).\n\n\n\n\n\n","category":"type"},{"location":"api/#SimplexTableaux.basic_vector-Tuple{Tableau}","page":"API","title":"SimplexTableaux.basic_vector","text":"basic_vector(T::Tableau)\n\nReturn the basic vector for T. This is the vector in which all nonbasic variables are 0. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.big_M_solve!","page":"API","title":"SimplexTableaux.big_M_solve!","text":"big_M_solve!(T::Tableau, M::Int=100, verbose::Bool=true)\n\nSolve the LP T using the big-M method.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimplexTableaux.big_M_tableau","page":"API","title":"SimplexTableaux.big_M_tableau","text":"big_M_tableau(T::Tableau, M::Int=100)\n\nForm a new tableau from T by adding m artificial variables  and add the terms +M*x_i (for each artificial variable x_i) to the objective function. Then set the basis to the columns for the artifical variables.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimplexTableaux.check_basis-Tuple{Tableau, Vector{Int64}}","page":"API","title":"SimplexTableaux.check_basis","text":"check_basis(T::Tableau, vars::Vector{Int})::Bool\n\nSee if the list of column indices vars forms a basis (feasible or not) for T.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.dual-Tuple{Tableau}","page":"API","title":"SimplexTableaux.dual","text":"dual(T::Tableau)\n\nCreate a tableau that is dual to T. \n\nCaveats:\n\nT should have been created from canonical data (not standard). [Standard LPs TBW.]\nThe returned tableau is set up as a minimization problem so the value of the solved LP is negative the desired value. However, the basic feasible vector is correct.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.dual_basic_vector-Tuple{Tableau}","page":"API","title":"SimplexTableaux.dual_basic_vector","text":"dual_basic_vector(T::Tableau)\n\nReturn the dual basic vector for T.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.find_a_basis","page":"API","title":"SimplexTableaux.find_a_basis","text":"find_a_basis(T::Tableau, verbose::Bool=true)\n\nReturn a feasible basis for the LP in T or nothing if none exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimplexTableaux.find_all_bases-Tuple{Tableau}","page":"API","title":"SimplexTableaux.find_all_bases","text":"find_all_bases(T::Tableau)\n\nReturn a list of all feasible bases for T.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.find_pivot-Tuple{Tableau, Int64}","page":"API","title":"SimplexTableaux.find_pivot","text":"find_pivot(T::Tableau, j::Int)\n\nFind a valid pivot in column j. Returns (i,j) showing where to pivot.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.find_pivot-Tuple{Tableau}","page":"API","title":"SimplexTableaux.find_pivot","text":"find_pivot(T::Tableau)\n\nFind a valid pivot for T or return (0,0) if none exists. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.find_pivot_column-Tuple{Tableau}","page":"API","title":"SimplexTableaux.find_pivot_column","text":"find_pivot_column(T::Tableau)\n\nFind a column with the most negative reduced cost  (i.e., the most positive value in the top row of the tableau).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.get_Abc-Tuple{Tableau}","page":"API","title":"SimplexTableaux.get_Abc","text":"get_Abc(T::Tableau)\n\nReturns a 3-tuple containing copies of the matrix A and the vectors b and c used to create T.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.get_basis-Tuple{Tableau}","page":"API","title":"SimplexTableaux.get_basis","text":"get_basis(T::Tableau)\n\nReturn the current basis (indices of basic variables).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.header-Tuple{Tableau}","page":"API","title":"SimplexTableaux.header","text":"header(T::Tableau)\n\nReturn the header (negative reduced costs) of T.\n\nExample\n\nFor this Tableau\n\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │  -2 │  -4 │  -2 │  -1 │   1 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   2 │   1 │   0 │   9 │  -1 │   9 │\n│   Cons 2 │ 0 │   1 │   1 │  -1 │   5 │   1 │   7 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nheader(T) returns the vector [-2, -4, -2, -1, 1].\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.in_dual_feasible_state-Tuple{Tableau}","page":"API","title":"SimplexTableaux.in_dual_feasible_state","text":"in_dual_feasible_state(T::Tableau)::Bool\n\nDetermine if the header of T is entirely nonpositive. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.in_feasible_state-Tuple{Tableau}","page":"API","title":"SimplexTableaux.in_feasible_state","text":"in_feasible_state(T::Tableau)::Bool\n\nReturn true is the current state of T is at a feasible vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.in_optimal_state-Tuple{Tableau}","page":"API","title":"SimplexTableaux.in_optimal_state","text":"in_optimal_state(T::Tableau)::Bool\n\nDetermine if T has been pivoted to a global minimum state.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.infer_basis!-Tuple{Tableau, Vector}","page":"API","title":"SimplexTableaux.infer_basis!","text":"infer_basis!(T::Tableau, x::Vector)\n\nWhen x is a basic feasbile vector for T, determine a basis  of columns to that effect.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.infer_basis!-Tuple{Tableau}","page":"API","title":"SimplexTableaux.infer_basis!","text":"infer_basis!(T::Tableau)\n\nFind the columns that form an elementary basis in T and assign that basis to T\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.is_canonical-Tuple{Tableau}","page":"API","title":"SimplexTableaux.is_canonical","text":"is_canonical(T::Tableau)::Bool\n\nReturn true if T was created from a canonical LP  and return false if it was created from a standard LP.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.is_infeasible-Tuple{Tableau}","page":"API","title":"SimplexTableaux.is_infeasible","text":"is_infeasible(T::Tableau)::Bool\n\nReturn true if the tableau represents an infeasible linear program (i.e., the  feasible region is empty).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.is_unbounded-Tuple{Tableau}","page":"API","title":"SimplexTableaux.is_unbounded","text":"is_unbounded(T::Tableau)::Bool\n\nReturn true is the linear program is unbounded (below).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.lp_solve","page":"API","title":"SimplexTableaux.lp_solve","text":"lp_solve(T::Tableau, verbose::Bool=true)\n\nUse a standard linear programming solver [HiGHS by defaut] to find the optimal solution to the LP in T. Returns the values of the variables. \n\nWith verbose set to true [default], the value of the objective function is printed. Set verbose to false to supress this. \n\n\n\n\n\n","category":"function"},{"location":"api/#SimplexTableaux.phase_one_tableau-Tuple{Tableau}","page":"API","title":"SimplexTableaux.phase_one_tableau","text":"phase_one_tableau(T::Tableau)\n\nCreate a tableau with additional slack variables from which it is  easy to extract a basis for T or determine that T is infeasible. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.pivot!-Tuple{Tableau, Int64, Int64}","page":"API","title":"SimplexTableaux.pivot!","text":"pivot!(T::Tableau, i::Int, j::Int)\n\nModify T by doing a pivot operation at contraint i  and variable x_j.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.ratios-Tuple{Tableau, Int64}","page":"API","title":"SimplexTableaux.ratios","text":"ratios(T::Tableau, col::Int)\n\nDisplay a table for determining a valid pivot for T in column col.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.restore!-Tuple{Tableau}","page":"API","title":"SimplexTableaux.restore!","text":"restore!(T::Tableau)\n\nRestore a Tableau based on the original data used to create it. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.rhs-Tuple{Tableau}","page":"API","title":"SimplexTableaux.rhs","text":"rhs(T::Tableau)\n\nReturn the right-hand column of the T. \n\nExample\n\nFor this Tableau\n\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │  -2 │  -4 │  -2 │  -1 │   1 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   2 │   1 │   0 │   9 │  -1 │   9 │\n│   Cons 2 │ 0 │   1 │   1 │  -1 │   5 │   1 │   7 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\nrhs(T) returns the vector [9,7].\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.scale_row!-Tuple{Tableau, Int64, Union{Integer, Rational}}","page":"API","title":"SimplexTableaux.scale_row!","text":"scale_row!(T::Tableau, i::Int, m::_Exact)\n\nModify T by multiplying row i (the i-th constraint) by m. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.set_basis!-Tuple{Tableau, Vector{Int64}}","page":"API","title":"SimplexTableaux.set_basis!","text":"set_basis!(T::Tableau, vars::Vector{Int})\n\nPivot T so that the variables specified in vars are the basic variables. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.set_basis!-Tuple{Tableau}","page":"API","title":"SimplexTableaux.set_basis!","text":"set_basis!(T::Tableau)\n\nInvoke find_a_basis(T) and use the result to establish a basis for T. Silently fail if no basis is found. \n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.simplex_solve!","page":"API","title":"SimplexTableaux.simplex_solve!","text":"simplex_solve!(T::Tableau, verbose::Bool=true)\n\nSolve T using the simplex method. \n\n\n\n\n\n","category":"function"},{"location":"api/#SimplexTableaux.status-Tuple{Tableau}","page":"API","title":"SimplexTableaux.status","text":"status(T::Tableau)::Symbol\n\nReturn an indicator for the status of the tableau T being one of:\n\n:no_basis – no basis has been established for this tableau\n:feasible – the tableau is in a feasible state, but not optimal (rhs is nonnegative).\n:infeasible – the tableau is in an infeasible state (rhs contains negative values).\n:optimal – the tableau has reached a global minimization point.\n:unbounded – no pivots are possible; objective function can be arbitrarily negative.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.swap_rows!-Tuple{Tableau, Int64, Int64}","page":"API","title":"SimplexTableaux.swap_rows!","text":"swap_rows!(T::Tableau, i::Int, j::Int)\n\nSwap constraint rows i and j in the tableau T.\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.value-Tuple{Tableau, Vector}","page":"API","title":"SimplexTableaux.value","text":"value(T::Tableau, x::Vector)\n\nReturn the value of the LP in T at the point x.\n\nThis can also be invoked as T(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#SimplexTableaux.value-Tuple{Tableau}","page":"API","title":"SimplexTableaux.value","text":"value(T::Tableau)\n\nReturn the value of the LP at the current basic vector. \n\n\n\n\n\n","category":"method"},{"location":"dual/#Duality","page":"Duality","title":"Duality","text":"","category":"section"},{"location":"dual/","page":"Duality","title":"Duality","text":"The duality functionality is under construction. I don't know how you found your way here, but please understand that everything on this page is in pre-beta.","category":"page"},{"location":"dual/#The-dual-function","page":"Duality","title":"The dual function","text":"","category":"section"},{"location":"dual/","page":"Duality","title":"Duality","text":"If a tableau T is created from a canonical minimization problem, then dual(T)  returns a new tableau for its dual linear program. However, dual(T) is  also a minimization problem. The minimum value of dual(T) is negative that of T. ","category":"page"},{"location":"dual/","page":"Duality","title":"Duality","text":"That is, if T represents the LP min c^T x s.t. Ax ge b, xge0, then dual(T) respresents the LP min b^T y s.t. -A^T y le -c, yge0. ","category":"page"},{"location":"dual/#Example","page":"Duality","title":"Example","text":"","category":"section"},{"location":"dual/","page":"Duality","title":"Duality","text":"julia> A = [11 2 11; 8 6 9; 8 8 5; 6 5 8; 4 1 2; 2 -1 4];\n\njulia> b = [0, 1, 10, 3, 2, 5];\n\njulia> c = [3, 4, 7];\n\njulia> T = Tableau(A,b,c):\n\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ x_7 │ x_8 │ x_9 │ RHS │\n│ Obj Func │ 1 │  -3 │  -4 │  -7 │   0 │   0 │   0 │   0 │   0 │   0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │  11 │   2 │  11 │  -1 │   0 │   0 │   0 │   0 │   0 │   0 │\n│   Cons 2 │ 0 │   8 │   6 │   9 │   0 │  -1 │   0 │   0 │   0 │   0 │   1 │\n│   Cons 3 │ 0 │   8 │   8 │   5 │   0 │   0 │  -1 │   0 │   0 │   0 │  10 │\n│   Cons 4 │ 0 │   6 │   5 │   8 │   0 │   0 │   0 │  -1 │   0 │   0 │   3 │\n│   Cons 5 │ 0 │   4 │   1 │   2 │   0 │   0 │   0 │   0 │  -1 │   0 │   2 │\n│   Cons 6 │ 0 │   2 │  -1 │   4 │   0 │   0 │   0 │   0 │   0 │  -1 │   5 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘","category":"page"},{"location":"dual/","page":"Duality","title":"Duality","text":"The result of simplex_solve! on this tableau is 152. ","category":"page"},{"location":"dual/","page":"Duality","title":"Duality","text":"The tableau for the dual problem is:","category":"page"},{"location":"dual/","page":"Duality","title":"Duality","text":"julia> dT = dual(T)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ x_7 │ x_8 │ x_9 │ RHS │\n│ Obj Func │ 1 │   0 │   1 │  10 │   3 │   2 │   5 │   0 │   0 │   0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │ -11 │  -8 │  -8 │  -6 │  -4 │  -2 │  -1 │   0 │   0 │  -3 │\n│   Cons 2 │ 0 │  -2 │  -6 │  -8 │  -5 │  -1 │   1 │   0 │  -1 │   0 │  -4 │\n│   Cons 3 │ 0 │ -11 │  -9 │  -5 │  -8 │  -2 │  -4 │   0 │   0 │  -1 │  -7 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘","category":"page"},{"location":"dual/","page":"Duality","title":"Duality","text":"The result of simplex_solve!(dT) is -152. ","category":"page"},{"location":"other/#Other-Features","page":"Other Functions","title":"Other Features","text":"","category":"section"},{"location":"other/#Status-Functions","page":"Other Functions","title":"Status Functions","text":"","category":"section"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":"The status function returns a symbol indicating the state of the tableau, T. The result  of status(T) is one of the following:","category":"page"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":":no_basis – no basis has been established for this tableau.\n:feasible – the tableau is in a feasible state, but not optimal (rhs is nonnegative).\n:infeasible – the tableau is in an infeasible state (rhs contains negative values). \n:optimal – the tableau has reached a global minimization point, This supercedes :feasible. \n:unbounded – the tableau has reached a feasible state, but there are no pivots; the objective function value can be arbitrarily negative. This supercedes :feasible.","category":"page"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":"These functions are superfluous but may be convenient: ","category":"page"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":"in_feasible_state(T) returns true if the current basic vector is in the feasible region (including if at optimality).\nin_optimal_state(T) returns true if the tableau has reached an optimal (minimal) state.","category":"page"},{"location":"other/#Miscellaneous-Functions","page":"Other Functions","title":"Miscellaneous Functions","text":"","category":"section"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":"basic_vector(T) returns the vector in which the nonbasic variables have been set to zero. \ndual_basic_vector(T) returns the dual basic vector. \nheader(T) returns the top row of T (negative reduced costs). Does not include the 1 in column 0 nor the value in the last column. \nget_Abc(T) returns the original matrix A and the vectors b and c for the standard presentation of the linear program.\nget_basis(T) returns the column numbers of the current basis.\nis_infeasible(T) returns true if the linear program's feasible region is empty. \nis_unbounded(T) returns true if the linear program is unbounded (below).\nrhs(T) returns the righthand column of T (from row 1 onward – does not include the value in row 0).\nvalue(T) returns the objective function value of the current basic vector. \nvalue(T,x) returns the objective function value for the vector x. May also be invoked as T(x). ","category":"page"},{"location":"other/#Return-to-Start","page":"Other Functions","title":"Return to Start","text":"","category":"section"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":"The function restore! returns the tableau to its state when it was constructed. ","category":"page"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":"julia> T\n┌──────────┬───┬─────┬─────┬────────┬─────┬─────────┬──────────┐\n│          │ z │ x_1 │ x_2 │    x_3 │ x_4 │     x_5 │      RHS │\n│ Obj Func │ 1 │   0 │   0 │ -25/47 │   0 │ -110/47 │ 13500/47 │\n├──────────┼───┼─────┼─────┼────────┼─────┼─────────┼──────────┤\n│   Cons 1 │ 0 │   1 │   0 │   1/47 │   0 │   -5/47 │   400/47 │\n│   Cons 2 │ 0 │   0 │   0 │ -25/47 │   1 │  -16/47 │  -600/47 │\n│   Cons 3 │ 0 │   0 │   1 │  -5/47 │   0 │    3/94 │   350/47 │\n└──────────┴───┴─────┴─────┴────────┴─────┴─────────┴──────────┘\n\n\njulia> restore!(T)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │ -25 │ -10 │   0 │   0 │   0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   3 │  10 │  -1 │   0 │   0 │ 100 │\n│   Cons 2 │ 0 │   5 │   6 │   0 │  -1 │   0 │ 100 │\n│   Cons 3 │ 0 │  10 │   2 │   0 │   0 │  -1 │ 100 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘","category":"page"},{"location":"other/#LaTeX-Output","page":"Other Functions","title":"LaTeX Output","text":"","category":"section"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":"Using LatexPrint users can get the  code for pasting into a LaTeX document.","category":"page"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":"julia> using LatexPrint\n\njulia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬──────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │  x_5 │ RHS │\n│ Obj Func │ 1 │   0 │  -3 │  -2 │   8 │    0 │   9 │\n├──────────┼───┼─────┼─────┼─────┼─────┼──────┼─────┤\n│   Cons 1 │ 0 │   1 │ 1/2 │   0 │ 9/2 │ -1/2 │ 9/2 │\n│   Cons 2 │ 0 │   0 │ 1/2 │  -1 │ 1/2 │  3/2 │ 5/2 │\n└──────────┴───┴─────┴─────┴─────┴─────┴──────┴─────┘\n\n\njulia> lap(T)\n\\begin{tabular}{|c|ccccc|c|}\\hline \n{\\Large\\strut}$z$ &$x_{1}$ & $x_{2}$ & $x_{3}$ & $x_{4}$ & $x_{5}$ & RHS \\\\\n{\\Large\\strut}$1$ & $0$ & $-3$ & $-2$ & $8$ & $0$ & $9$\\\\\n\\hline \n{\\Large\\strut}$0$ & $1$ & $\\frac{1}{2}$ & $0$ & $\\frac{9}{2}$ & $\\frac{-1}{2}$ & $\\frac{9}{2}$\\\\\n{\\Large\\strut}$0$ & $0$ & $\\frac{1}{2}$ & $-1$ & $\\frac{1}{2}$ & $\\frac{3}{2}$ & $\\frac{5}{2}$\\\\\n\\hline \n\\end{tabular}","category":"page"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":"Here is the LaTeX output:","category":"page"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":"(Image: )","category":"page"},{"location":"other/#Other-Public-Functions","page":"Other Functions","title":"Other Public Functions","text":"","category":"section"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":"Presently, these functions are exported in SimplexTableaux but might be hidden in future releases.  They are not likely to be useful to the users of this module.  See the doc strings for more information:","category":"page"},{"location":"other/","page":"Other Functions","title":"Other Functions","text":"big_M_tableau\ncheck_basis\nfind_pivot_column\ninfer_basis!","category":"page"},{"location":"#SimplexTableaux","page":"Overview","title":"SimplexTableaux","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This module demonstrates how to solve linear programs using the Simplex Method.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"In particular, it can be used to solve feasible optimization problems of the form  min c^T x subject to Ax  b and x ge 0 (canonical form) and of the form min c^T x subject to Ax = b and x ge 0 (standard form).","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"See the Tutorial for a thorough introduction to this module.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This is a demonstration project for illustrating the Simplex Method and for solving small linear programs.  All arithmetic is exact (using arbitrary precision rational numbers).","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This module serves as a supplement to the (currently under construction) textbook Mathematical Optimization: From Knowledge to Wisdom.","category":"page"},{"location":"#Feedback-please","page":"Overview","title":"Feedback please","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"I am hoping this module is useful for those learning the Simplex Method.  Whether you are a student or an instructor, I would appreciate your feedback. ","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This is a step-by-step guide for solving linear programs using the SimplexTableau module.","category":"page"},{"location":"tutorial/#Setting-Up","page":"Tutorial","title":"Setting Up","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This module enables the user to solve linear program problems in one of the following two forms:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Standard: min c^T  x subject to A x = b x  0. Use: Tableau(A,b,c,false). \nCanonical: min c^T  x subject to A x  b x  0. Use: Tableau(A,b,c).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, A is an m times n-matrix, b is an m-vector, and c is an n-vector. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Only minimization problems are supported. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Every number entered into a Tableau must be an  Integer  or a Rational.  Internally, all numbers are converted to Rational{BigInt} type. This module does not support linear programs with floating point data.","category":"page"},{"location":"tutorial/#Example:-Standard-form-linear-program","page":"Tutorial","title":"Example: Standard form linear program","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let  A=left beginarrayrrrrrr 1  8  -2  8  6  -1 \n2  6  2  9  2  1 \n6  3  5  9  7  1 \nendarray right,  b= left beginarrayr -2 \n4 \n9 \nendarray right, and c = left beginarrayr 0 \n3 \n3 \n-1 \n2 \n-4 \nendarray right. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here is how to set up the standard LP min c^T x s.t. Ax=bxge0:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> A = [1 8 -2 8 6 -1; 2 6 2 9 2 1; 6 3 5 9 7 1];\n\njulia> b = [-2, 4, 9];\n\njulia> c = [0, 3, 3, -1, 2, -4];\n\njulia> T = Tableau(A, b, c, false)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │\n│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │\n│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note the false in the function call; it indicates that this is not canoncial (that is, it is standard) so no slack variables are added. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Written as a (partitioned) matrix, this tableau looks like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"left\nbeginarrayrrrrrrrr\n1  0  -3  -3  1  -2  4  0  hline\n0  1  8  -2  8  6  -1  -2 \n0  2  6  2  9  2  1  4 \n0  6  3  5  9  7  1  9 \nendarray\nright","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The top (header) row represents the objective function we wish to minimize: z = 0x_1 + 3x_2 + 3x_3 - x_4 + 2x_5 - 4x_6. It is rearranged to appear in the form  z - 0x_1 - 3x_2 - 3x_3 + x_4 - 2x_5 + 4x_6 = 0. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The next three rows are the constraints from A x = b. For example, the first constraint is x_1 + 8x_2 - 2x_3 + 8x_4 + 6x_5 - x_6 = -2.","category":"page"},{"location":"tutorial/#Example:-Canonical-form-linear-program","page":"Tutorial","title":"Example: Canonical form linear program","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let A=left beginarrayrrrr 7  5  2  9 \n5  9  5  5 \nendarray right,  b=left beginarrayr 2 \n5 \nendarray right  and c=left beginarrayr 7 \n6 \n3 \n4 \nendarray right. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here is how to set up the canonical LP min c^T x s.t. Axge b xge0:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> A = [7 5 2 9; 5 9 5 5];\n\njulia> b = [2, 5];\n\njulia> c = [7, 6, 3, 4];\n\njulia> T = Tableau(A, b, c)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │  -7 │  -6 │  -3 │  -4 │   0 │   0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   7 │   5 │   2 │   9 │  -1 │   0 │   2 │\n│   Cons 2 │ 0 │   5 │   9 │   5 │   5 │   0 │  -1 │   5 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that x_5 and x_6 are added as slack variables. Therefore the first constraint is 7x_1 + 5x_2 +2 x_3 +9x_4 - x_5=2 which is equivalent to 7x_1 + 5x_2 +2 x_3 +9x_4 ge 2. With these extra variables, the LP is now in standard form.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The objective function is z = 7x_1 + 6x_2 + 3x_3 + 4x_4 that is encoded in the tableau  as z-7x_1 -6x_2 -3x_3 -4x_4=0. ","category":"page"},{"location":"tutorial/#Pivoting","page":"Tutorial","title":"Pivoting","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pivoting is a fundamental operation in linear algebra that is used extensively in the Simplex Method. A pivot on element a_ij of a matrix begins by multiplying row i by 1a_ij. This leaves a 1 in position ij. Then multiples of row i are added to the other rows so that all the other entries in column j are now 0. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, suppose we wish to pivot on the 2 in this matrix:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"left\nbeginarrayrrrrrrrr\n1  -7  -6  -3  -4  0  0  0  hline\n0  7  5  fbox2  9  -1  0  2 \n0  5  9  5  5  0  -1  5 \nendarray\nright","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The main body of the matrix lies below the header row and between the vertical dividers. This is considered to be the 13-entry of the matrix: this corresponds to the constraint 1 in the column of x_3. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"First we multiply row 1 through by 12:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"left\nbeginarrayrrrrrrrr\n1  -7  -6  -3  -4  0  0  0  hline\n0  72  52  1  92  -12  0  1 \n0  5  9  5  5  0  -1  5 \nendarray\nright","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Then we add 3 times the first row to the header (row 0) and -5 times the first row to the second row:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"left\nbeginarrayrrrrrrrr\n1  72  32  0  192  -32  0  3  hline\n0  72  52  1  92  -12  0  1 \n0  -252  -72  0  -352  52  -1  0 \nendarray\nright","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the SimplexTableau module, this operation is accomplished with the pivot! function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │  -7 │  -6 │  -3 │  -4 │   0 │   0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   7 │   5 │   2 │   9 │  -1 │   0 │   2 │\n│   Cons 2 │ 0 │   5 │   9 │   5 │   5 │   0 │  -1 │   5 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> pivot!(T,1,3)\n[ Info: Unable to infer basis\n┌──────────┬───┬───────┬──────┬─────┬───────┬──────┬─────┬─────┐\n│          │ z │   x_1 │  x_2 │ x_3 │   x_4 │  x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   7/2 │  3/2 │   0 │  19/2 │ -3/2 │   0 │   3 │\n├──────────┼───┼───────┼──────┼─────┼───────┼──────┼─────┼─────┤\n│   Cons 1 │ 0 │   7/2 │  5/2 │   1 │   9/2 │ -1/2 │   0 │   1 │\n│   Cons 2 │ 0 │ -25/2 │ -7/2 │   0 │ -35/2 │  5/2 │  -1 │   0 │\n└──────────┴───┴───────┴──────┴─────┴───────┴──────┴─────┴─────┘","category":"page"},{"location":"tutorial/#Bases","page":"Tutorial","title":"Bases","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Simplex Method begins by finding a set of m columns (where m is the number of  constraints) that are linearly independent. We pivot on elements of those columns to  transform them into standard basis vectors. That is, in each of those columns there is a single 1  all other elements of that column are 0 (including in the header).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example we just considered, we see that pivoting on the -1 in the (26) position  will result in columns 3 and 6 forming a basis, and so those columns are called basic. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> T\n┌──────────┬───┬───────┬──────┬─────┬───────┬──────┬─────┬─────┐\n│          │ z │   x_1 │  x_2 │ x_3 │   x_4 │  x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   7/2 │  3/2 │   0 │  19/2 │ -3/2 │   0 │   3 │\n├──────────┼───┼───────┼──────┼─────┼───────┼──────┼─────┼─────┤\n│   Cons 1 │ 0 │   7/2 │  5/2 │   1 │   9/2 │ -1/2 │   0 │   1 │\n│   Cons 2 │ 0 │ -25/2 │ -7/2 │   0 │ -35/2 │  5/2 │  -1 │   0 │\n└──────────┴───┴───────┴──────┴─────┴───────┴──────┴─────┴─────┘\n\njulia> pivot!(T,2,6)\n┌──────────┬───┬──────┬─────┬─────┬──────┬──────┬─────┬─────┐\n│          │ z │  x_1 │ x_2 │ x_3 │  x_4 │  x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │  7/2 │ 3/2 │   0 │ 19/2 │ -3/2 │   0 │   3 │\n├──────────┼───┼──────┼─────┼─────┼──────┼──────┼─────┼─────┤\n│   Cons 1 │ 0 │  7/2 │ 5/2 │   1 │  9/2 │ -1/2 │   0 │   1 │\n│   Cons 2 │ 0 │ 25/2 │ 7/2 │   0 │ 35/2 │ -5/2 │   1 │   0 │\n└──────────┴───┴──────┴─────┴─────┴──────┴──────┴─────┴─────┘\n\njulia> get_basis(T)\n2-element Vector{Int64}:\n 3\n 6","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The get_basis function returns the current basis. If the tableau does not have a basis, a vector of all zeros is returned. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"On the computer display, the labels of the basic columns are green. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/#Setting-a-basis","page":"Tutorial","title":"Setting a basis","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The function set_basis! is used to select columns to be a basis. This is invoked as  set_basis(T, B) where B is a list of m indices specifying the columns to form a basis. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> set_basis!(T,[2,4])\n┌──────────┬───┬────────┬─────┬──────┬─────┬───────┬────────┬──────┐\n│          │ z │    x_1 │ x_2 │  x_3 │ x_4 │   x_5 │    x_6 │  RHS │\n│ Obj Func │ 1 │ -45/14 │   0 │  1/4 │   0 │ -3/28 │ -17/28 │ 13/4 │\n├──────────┼───┼────────┼─────┼──────┼─────┼───────┼────────┼──────┤\n│   Cons 1 │ 0 │   5/28 │   1 │  5/8 │   0 │  5/56 │  -9/56 │  5/8 │\n│   Cons 2 │ 0 │  19/28 │   0 │ -1/8 │   1 │ -9/56 │   5/56 │ -1/8 │\n└──────────┴───┴────────┴─────┴──────┴─────┴───────┴────────┴──────┘","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"However, this basis is not suitable for the Simplex Algorithm because the RHS column contains negative numbers. In other words, 24  is an infeasible basis. On the other hand 36 yields a  feasible tableau.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> set_basis!(T,[3,6])\n┌──────────┬───┬──────┬─────┬─────┬──────┬──────┬─────┬─────┐\n│          │ z │  x_1 │ x_2 │ x_3 │  x_4 │  x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │  7/2 │ 3/2 │   0 │ 19/2 │ -3/2 │   0 │   3 │\n├──────────┼───┼──────┼─────┼─────┼──────┼──────┼─────┼─────┤\n│   Cons 1 │ 0 │  7/2 │ 5/2 │   1 │  9/2 │ -1/2 │   0 │   1 │\n│   Cons 2 │ 0 │ 25/2 │ 7/2 │   0 │ 35/2 │ -5/2 │   1 │   0 │\n└──────────┴───┴──────┴─────┴─────┴──────┴──────┴─────┴─────┘","category":"page"},{"location":"tutorial/#Automatic-basis-selection","page":"Tutorial","title":"Automatic basis selection","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"While any m linearly independent columns may be selected to form a basis, finding a set of columns that yield a feasible tableau can be difficult. In a later section of this tutorial we describe a method for finding a basis,  but we also provide tools to make this easy.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The function find_a_basis automatically finds a feasible basis. Combined with set_basis!  the resut is a tableau that has been pivoted to a feasible configuation. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │  -7 │  -6 │  -3 │  -4 │   0 │   0 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   7 │   5 │   2 │   9 │  -1 │   0 │   2 │\n│   Cons 2 │ 0 │   5 │   9 │   5 │   5 │   0 │  -1 │   5 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> find_a_basis(T)\n2-element Vector{Int64}:\n 2\n 5\n\njulia> set_basis!(T,[2,5])\n┌──────────┬───┬───────┬─────┬─────┬───────┬─────┬──────┬──────┐\n│          │ z │   x_1 │ x_2 │ x_3 │   x_4 │ x_5 │  x_6 │  RHS │\n│ Obj Func │ 1 │ -11/3 │   0 │ 1/3 │  -2/3 │   0 │ -2/3 │ 10/3 │\n├──────────┼───┼───────┼─────┼─────┼───────┼─────┼──────┼──────┤\n│   Cons 1 │ 0 │   5/9 │   1 │ 5/9 │   5/9 │   0 │ -1/9 │  5/9 │\n│   Cons 2 │ 0 │ -38/9 │   0 │ 7/9 │ -56/9 │   1 │ -5/9 │  7/9 │\n└──────────┴───┴───────┴─────┴─────┴───────┴─────┴──────┴──────┘","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, using set_basis!(T), without specifying a basis,   invokes find_a_basis to choose the basis for you. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If the tableau does not have a feasible basis, find_a_basis returns a vector of all zeros.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │\n│ Obj Func │ 1 │  -3 │  -1 │  -5 │  -2 │  -5 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   3 │   2 │   2 │   2 │   3 │   4 │\n│   Cons 2 │ 0 │   4 │   4 │   3 │   5 │   2 │   2 │\n│   Cons 3 │ 0 │   1 │   2 │   4 │   2 │   1 │   1 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> find_a_basis(T)\n[ Info: No basis found.\n3-element Vector{Int64}:\n 0\n 0\n 0","category":"page"},{"location":"tutorial/#Listing-all-feasible-bases","page":"Tutorial","title":"Listing all feasible bases","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The function find_all_bases returns a list of all feasible bases for a tableau:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │\n│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │\n│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> find_all_bases(T)\n6-element Vector{Vector{Int64}}:\n [1, 2, 3]\n [1, 3, 4]\n [1, 3, 6]\n [2, 3, 5]\n [3, 4, 5]\n [3, 5, 6]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The find_all_bases function is highly inefficient and only suitable for small linear programs. ","category":"page"},{"location":"tutorial/#Simplex-Method","page":"Tutorial","title":"Simplex Method","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Simplex Method finds the minimum objective value for a linear program, as well as the  vector at which that minimum is achieved. ","category":"page"},{"location":"tutorial/#Overview","page":"Tutorial","title":"Overview","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The steps in the Simplex Method are:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Select a feasible starting basis. (If there is no such basis, the LP is infeasible.)\nFind a column headed by a positive number. (If there are none, the LP has reached an optimal state.)\nForm the ratios between the righthand column and the positive members of the column selected in step 2. \nPivot on whichever entry in the selected column gives the lowest ratio. (If there are no positive numbers in the selected column, the LP is unbounded.)\nGo to step 2. ","category":"page"},{"location":"tutorial/#Manual-execution-of-the-Simplex-Algorithm","page":"Tutorial","title":"Manual execution of the Simplex Algorithm","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first step is to find a first basis for a tableau T either:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use B = find_a_basis(T); set_basis!(T,B) or more simply\nset_basis!(T).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │\n│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │\n│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> set_basis!(T)\n┌──────────┬───┬─────────┬──────────┬─────┬─────┬─────┬──────────┬────────┐\n│          │ z │     x_1 │      x_2 │ x_3 │ x_4 │ x_5 │      x_6 │    RHS │\n│ Obj Func │ 1 │ 795/284 │ -931/142 │   0 │   0 │   0 │ 1265/284 │ 334/71 │\n├──────────┼───┼─────────┼──────────┼─────┼─────┼─────┼──────────┼────────┤\n│   Cons 1 │ 0 │ 187/284 │ -117/142 │   1 │   0 │   0 │   85/284 │ 110/71 │\n│   Cons 2 │ 0 │   -1/71 │    62/71 │   0 │   1 │   0 │     6/71 │   6/71 │\n│   Cons 3 │ 0 │ 115/284 │  -15/142 │   0 │   0 │   1 │  -51/284 │   5/71 │\n└──────────┴───┴─────────┴──────────┴─────┴─────┴─────┴──────────┴────────┘","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Later, we show how to find a first basis manually. See Finding a first basis later in this tutorial. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next we need to select a column in which to pivot. In this example, there are two columns headed by positive numbers: Column 1 is headed by 795/284 and column 6 is headed by 1265/284.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is possible to use the function find_pivot(T) to select the element on which to pivot.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> find_pivot(T)\n(2, 6)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tells us to pivot at the (26)-entry of the tableau (where we see the value 671). ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"While the find_pivot function suggested we pivot in column 6, we see that column 1 is also headed by a positive number, so we have the option to select a pivot there.  We can use the ratios functions to calculate the appropriate pivot for a user-selected column. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> T\n┌──────────┬───┬─────────┬──────────┬─────┬─────┬─────┬──────────┬────────┐\n│          │ z │     x_1 │      x_2 │ x_3 │ x_4 │ x_5 │      x_6 │    RHS │\n│ Obj Func │ 1 │ 795/284 │ -931/142 │   0 │   0 │   0 │ 1265/284 │ 334/71 │\n├──────────┼───┼─────────┼──────────┼─────┼─────┼─────┼──────────┼────────┤\n│   Cons 1 │ 0 │ 187/284 │ -117/142 │   1 │   0 │   0 │   85/284 │ 110/71 │\n│   Cons 2 │ 0 │   -1/71 │    62/71 │   0 │   1 │   0 │     6/71 │   6/71 │\n│   Cons 3 │ 0 │ 115/284 │  -15/142 │   0 │   0 │   1 │  -51/284 │   5/71 │\n└──────────┴───┴─────────┴──────────┴─────┴─────┴─────┴──────────┴────────┘\n\n\njulia> ratios(T,1)\n        Ratios for column 1 headed by 795/284\n                Best pivot is in row 3\n┌────────────┬──────────┬────────┬───────┬───────────┐\n│ Constraint │ Column 1 │    RHS │ Ratio │   Decimal │\n├────────────┼──────────┼────────┼───────┼───────────┤\n│          1 │  187/284 │ 110/71 │ 40/17 │ 2.3529412 │\n│          2 │    -1/71 │   6/71 │   --- │       --- │\n│          3 │  115/284 │   5/71 │  4/23 │ 0.1739130 │\n└────────────┴──────────┴────────┴───────┴───────────┘","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This analysis shows that if we decide to pivot in column 1, we should do so at the (31)-entry. Here is the result:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> pivot!(T,3,1)\n┌──────────┬───┬─────┬─────────┬─────┬─────┬──────────┬─────────┬───────┐\n│          │ z │ x_1 │     x_2 │ x_3 │ x_4 │      x_5 │     x_6 │   RHS │\n│ Obj Func │ 1 │   0 │ -134/23 │   0 │   0 │  -159/23 │  131/23 │ 97/23 │\n├──────────┼───┼─────┼─────────┼─────┼─────┼──────────┼─────────┼───────┤\n│   Cons 1 │ 0 │   0 │  -15/23 │   1 │   0 │ -187/115 │  68/115 │ 33/23 │\n│   Cons 2 │ 0 │   0 │   20/23 │   0 │   1 │    4/115 │   9/115 │  2/23 │\n│   Cons 3 │ 0 │   1 │   -6/23 │   0 │   0 │  284/115 │ -51/115 │  4/23 │\n└──────────┴───┴─────┴─────────┴─────┴─────┴──────────┴─────────┴───────┘","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now the column 6 is the only one headed by a positive number. We can use find_pivot(T) or use ratios to find the smallest ratio:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> ratios(T,6)\n         Ratios for column 6 headed by 131/23\n                Best pivot is in row 2\n┌────────────┬──────────┬───────┬────────┬───────────┐\n│ Constraint │ Column 6 │   RHS │  Ratio │   Decimal │\n├────────────┼──────────┼───────┼────────┼───────────┤\n│          1 │   68/115 │ 33/23 │ 165/68 │ 2.4264706 │\n│          2 │    9/115 │  2/23 │   10/9 │ 1.1111111 │\n│          3 │  -51/115 │  4/23 │    --- │       --- │\n└────────────┴──────────┴───────┴────────┴───────────┘","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Pivoting at (26):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> pivot!(T,2,6)\n┌──────────┬───┬─────┬────────┬─────┬────────┬───────┬─────┬───────┐\n│          │ z │ x_1 │    x_2 │ x_3 │    x_4 │   x_5 │ x_6 │   RHS │\n│ Obj Func │ 1 │   0 │ -622/9 │   0 │ -655/9 │ -85/9 │   0 │ -19/9 │\n├──────────┼───┼─────┼────────┼─────┼────────┼───────┼─────┼───────┤\n│   Cons 1 │ 0 │   0 │  -65/9 │   1 │  -68/9 │ -17/9 │   0 │   7/9 │\n│   Cons 2 │ 0 │   0 │  100/9 │   0 │  115/9 │   4/9 │   1 │  10/9 │\n│   Cons 3 │ 0 │   1 │   14/3 │   0 │   17/3 │   8/3 │   0 │   2/3 │\n└──────────┴───┴─────┴────────┴─────┴────────┴───────┴─────┴───────┘","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are no positive entries in the top row signalling that the tableau has reached its optimal state. This is verified by the status function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> status(T)\n:optimal","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, we get the minimum value and the vector that attains that value:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> value(T)\n-19//9\n\njulia> basic_vector(T)\n6-element Vector{Rational}:\n  2//3\n   0\n  7//9\n   0\n   0\n 10//9","category":"page"},{"location":"tutorial/#Fully-automatic-execution-of-the-Simplex-Algorithm","page":"Tutorial","title":"Fully automatic execution of the Simplex Algorithm","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The simplex_solve! function does all the steps of the Simplex Method without requiring any interaction with the user. We return the tableau T to its original state with restore!(T) and then solve the LP using simplex_solver:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> restore!(T)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │\n│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │\n│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\njulia> simplex_solve!(T)\n[ Info: Finding an initial basis.\nStarting basis found: [3, 4, 5]\nStarting tableau\n\n┌──────────┬───┬─────────┬──────────┬─────┬─────┬─────┬──────────┬────────┐\n│          │ z │     x_1 │      x_2 │ x_3 │ x_4 │ x_5 │      x_6 │    RHS │\n│ Obj Func │ 1 │ 795/284 │ -931/142 │   0 │   0 │   0 │ 1265/284 │ 334/71 │\n├──────────┼───┼─────────┼──────────┼─────┼─────┼─────┼──────────┼────────┤\n│   Cons 1 │ 0 │ 187/284 │ -117/142 │   1 │   0 │   0 │   85/284 │ 110/71 │\n│   Cons 2 │ 0 │   -1/71 │    62/71 │   0 │   1 │   0 │     6/71 │   6/71 │\n│   Cons 3 │ 0 │ 115/284 │  -15/142 │   0 │   0 │   1 │  -51/284 │   5/71 │\n└──────────┴───┴─────────┴──────────┴─────┴─────┴─────┴──────────┴────────┘\n\nPivot 1 at (2, 6)\n\n┌──────────┬───┬───────┬─────────┬─────┬──────────┬─────┬─────┬─────┐\n│          │ z │   x_1 │     x_2 │ x_3 │      x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │ 85/24 │ -631/12 │   0 │ -1265/24 │   0 │   0 │ 1/4 │\n├──────────┼───┼───────┼─────────┼─────┼──────────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │ 17/24 │  -47/12 │   1 │   -85/24 │   0 │   0 │ 5/4 │\n│   Cons 2 │ 0 │  -1/6 │    31/3 │   0 │     71/6 │   0 │   1 │   1 │\n│   Cons 3 │ 0 │   3/8 │     7/4 │   0 │     17/8 │   1 │   0 │ 1/4 │\n└──────────┴───┴───────┴─────────┴─────┴──────────┴─────┴─────┴─────┘\n\nPivot 2 at (3, 1)\n\n┌──────────┬───┬─────┬────────┬─────┬────────┬───────┬─────┬───────┐\n│          │ z │ x_1 │    x_2 │ x_3 │    x_4 │   x_5 │ x_6 │   RHS │\n│ Obj Func │ 1 │   0 │ -622/9 │   0 │ -655/9 │ -85/9 │   0 │ -19/9 │\n├──────────┼───┼─────┼────────┼─────┼────────┼───────┼─────┼───────┤\n│   Cons 1 │ 0 │   0 │  -65/9 │   1 │  -68/9 │ -17/9 │   0 │   7/9 │\n│   Cons 2 │ 0 │   0 │  100/9 │   0 │  115/9 │   4/9 │   1 │  10/9 │\n│   Cons 3 │ 0 │   1 │   14/3 │   0 │   17/3 │   8/3 │   0 │   2/3 │\n└──────────┴───┴─────┴────────┴─────┴────────┴───────┴─────┴───────┘\n\nOptimality reached. Pivot count = 2\nMinimal value = -19/9 = -2.111111111111111\n6-element Vector{Rational}:\n  2//3\n   0\n  7//9\n   0\n   0\n 10//9","category":"page"},{"location":"tutorial/#Numerically","page":"Tutorial","title":"Numerically","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The function lp_solve also solves linear programs but uses floating point rather than exact arithmetic. It uses the HiGHS solver to find the optimal solution: ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> lp_solve(T)\nMinimal objective value = -2.1111111111111183\n\n6-element Vector{Float64}:\n 0.6666666666666666\n 0.0\n 0.7777777777777776\n 0.0\n 0.0\n 1.1111111111111127","category":"page"},{"location":"tutorial/#Finding-a-First-Basis","page":"Tutorial","title":"Finding a First Basis","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Given a (standard form) linear program with n variables and m constraints, we form an  auxilliary LP as follows: ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Create m additional variables, x_n+1 x_n+2ldotsx_n+m.\nIf a constraint has a negative right-hand side, multiply both sides by -1. This ensures that all constraints have a nonnegative right-hand side. \nAdd a +x_n+i term to the left-hand side of constraint i for i=12ldotsm. \nUse x_n+1 + x_n+2 + cdots + x_n+m as the objective function to be minimized.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this new tableau, it is immediate that the new, auxilliary columns form a feasible basis. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Use the function phase_one_tableau build this auxilliary tableau from the original:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> T\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │\n│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │  # note the RHS of row 1 is negative\n│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │\n│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\n\njulia> TT = phase_one_tableau(T)\n┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐\n│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ x_7 │ x_8 │ x_9 │ RHS │\n│ Obj Func │ 1 │   7 │   1 │   9 │  10 │   3 │   3 │   0 │   0 │   0 │  15 │\n├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤\n│   Cons 1 │ 0 │  -1 │  -8 │   2 │  -8 │  -6 │   1 │   1 │   0 │   0 │   2 │ \n│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   0 │   1 │   0 │   4 │\n│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   0 │   0 │   1 │   9 │\n└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘\n\njulia> get_basis(TT)\n3-element Vector{Int64}:\n 7\n 8\n 9","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We now solve TT by the Simplex Method either manually or automatically:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> simplex_solve!(TT, false);   # the false argument supresses the verbose output\n\njulia> TT\n┌──────────┬───┬─────────┬──────────┬─────┬─────┬─────┬─────────┬─────────┬─────────┬────────┬────────┐\n│          │ z │     x_1 │      x_2 │ x_3 │ x_4 │ x_5 │     x_6 │     x_7 │     x_8 │    x_9 │    RHS │\n│ Obj Func │ 1 │       0 │        0 │   0 │   0 │   0 │       0 │      -1 │      -1 │     -1 │      0 │\n├──────────┼───┼─────────┼──────────┼─────┼─────┼─────┼─────────┼─────────┼─────────┼────────┼────────┤\n│   Cons 1 │ 0 │ 187/284 │ -117/142 │   1 │   0 │   0 │  85/284 │  45/284 │   1/142 │ 19/142 │ 110/71 │\n│   Cons 2 │ 0 │   -1/71 │    62/71 │   0 │   1 │   0 │    6/71 │   -1/71 │   11/71 │  -4/71 │   6/71 │\n│   Cons 3 │ 0 │ 115/284 │  -15/142 │   0 │   0 │   1 │ -51/284 │ -27/284 │ -29/142 │ 17/142 │   5/71 │\n└──────────┴───┴─────────┴──────────┴─────┴─────┴─────┴─────────┴─────────┴─────────┴────────┴────────┘\n\njulia> value(TT)\n0//1\n\njulia> get_basis(TT)\n3-element Vector{Int64}:\n 3\n 4\n 5","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Because the value of the final auxilliary tableau is zero, its basis is the starting basis for T.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If the final value for the auxilliary tableau is not zero, then the original tableau is infeasible. ","category":"page"}]
}
