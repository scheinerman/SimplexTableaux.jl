<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · SimplexTableaux</title><meta name="title" content="Tutorial · SimplexTableaux"/><meta property="og:title" content="Tutorial · SimplexTableaux"/><meta property="twitter:title" content="Tutorial · SimplexTableaux"/><meta name="description" content="Documentation for SimplexTableaux."/><meta property="og:description" content="Documentation for SimplexTableaux."/><meta property="twitter:description" content="Documentation for SimplexTableaux."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SimplexTableaux</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Setting-Up"><span>Setting Up</span></a></li><li><a class="tocitem" href="#Pivoting"><span>Pivoting</span></a></li><li><a class="tocitem" href="#Bases"><span>Bases</span></a></li><li><a class="tocitem" href="#Simplex-Method"><span>Simplex Method</span></a></li><li><a class="tocitem" href="#Finding-a-First-Basis"><span>Finding a First Basis</span></a></li></ul></li><li><a class="tocitem" href="../other/">Other Functions</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/scheinerman/SimplexTableaux.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/scheinerman/SimplexTableaux.jl/blob/main/docs/src/tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>This is a step-by-step guide for solving linear programs using the <code>SimplexTableau</code> module.</p><h2 id="Setting-Up"><a class="docs-heading-anchor" href="#Setting-Up">Setting Up</a><a id="Setting-Up-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-Up" title="Permalink"></a></h2><p>This module enables the user to solve linear program problems in one of the following two forms:</p><ul><li><strong>Standard</strong>: <span>$\min c^T  x$</span> subject to <span>$A x = b, x ≥ 0$</span>. Use: <code>Tableau(A,b,c,false)</code>. </li><li><strong>Canonical</strong>: <span>$\min c^T  x$</span> subject to <span>$A x ≥ b, x ≥ 0$</span>. Use: <code>Tableau(A,b,c)</code>.</li></ul><p>Here, <span>$A$</span> is an <span>$m \times n$</span>-matrix, <span>$b$</span> is an <span>$m$</span>-vector, and <span>$c$</span> is an <span>$n$</span>-vector. </p><blockquote><p>Only minimization problems are supported. </p></blockquote><blockquote><p>Every number entered into a <code>Tableau</code> must be an  <code>Integer</code>  or a <code>Rational</code>.  Internally, all numbers are converted to <code>Rational{BigInt}</code> type. This module does not support linear programs with floating point data.</p></blockquote><h3 id="Example:-Standard-form-linear-program"><a class="docs-heading-anchor" href="#Example:-Standard-form-linear-program">Example: Standard form linear program</a><a id="Example:-Standard-form-linear-program-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Standard-form-linear-program" title="Permalink"></a></h3><p>Let  <span>$A=\left[ \begin{array}{rrrrrr} 1 &amp; 8 &amp; -2 &amp; 8 &amp; 6 &amp; -1 \\
2 &amp; 6 &amp; 2 &amp; 9 &amp; 2 &amp; 1 \\
6 &amp; 3 &amp; 5 &amp; 9 &amp; 7 &amp; 1 \\
\end{array} \right]$</span>,  <span>$b= \left[ \begin{array}{r} -2 \\
4 \\
9 \\
\end{array} \right]$</span>, and <span>$c = \left[ \begin{array}{r} 0 \\
3 \\
3 \\
-1 \\
2 \\
-4 \\
\end{array} \right]$</span>. </p><p>Here is how to set up the standard LP <span>$\min c^T x$</span> s.t. <span>$Ax=b,x\ge0$</span>:</p><pre><code class="nohighlight hljs">julia&gt; A = [1 8 -2 8 6 -1; 2 6 2 9 2 1; 6 3 5 9 7 1];

julia&gt; b = [-2, 4, 9];

julia&gt; c = [0, 3, 3, -1, 2, -4];

julia&gt; T = Tableau(A, b, c, false)
┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │
├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │
│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │
│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │
└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘</code></pre><p>Note the <code>false</code> in the function call; it indicates that this is not canoncial (that is, it is standard) so no slack variables are added. </p><p>Written as a (partitioned) matrix, this tableau looks like this:</p><p class="math-container">\[\left[
\begin{array}{r|rrrrrr|r}
1 &amp; 0 &amp; -3 &amp; -3 &amp; 1 &amp; -2 &amp; 4 &amp; 0 \\ \hline
0 &amp; 1 &amp; 8 &amp; -2 &amp; 8 &amp; 6 &amp; -1 &amp; -2 \\
0 &amp; 2 &amp; 6 &amp; 2 &amp; 9 &amp; 2 &amp; 1 &amp; 4 \\
0 &amp; 6 &amp; 3 &amp; 5 &amp; 9 &amp; 7 &amp; 1 &amp; 9 \\
\end{array}
\right]\]</p><p>The top (header) row represents the objective function we wish to minimize: <span>$z = 0x_1 + 3x_2 + 3x_3 - x_4 + 2x_5 - 4x_6$</span>. It is rearranged to appear in the form  <span>$z - 0x_1 - 3x_2 - 3x_3 + x_4 - 2x_5 + 4x_6 = 0$</span>. </p><p>The next three rows are the constraints from <span>$A x = b$</span>. For example, the first constraint is <span>$x_1 + 8x_2 - 2x_3 + 8x_4 + 6x_5 - x_6 = -2$</span>.</p><h3 id="Example:-Canonical-form-linear-program"><a class="docs-heading-anchor" href="#Example:-Canonical-form-linear-program">Example: Canonical form linear program</a><a id="Example:-Canonical-form-linear-program-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Canonical-form-linear-program" title="Permalink"></a></h3><p>Let <span>$A=\left[ \begin{array}{rrrr} 7 &amp; 5 &amp; 2 &amp; 9 \\
5 &amp; 9 &amp; 5 &amp; 5 \\
\end{array} \right]$</span>,  <span>$b=\left[ \begin{array}{r} 2 \\
5 \\
\end{array} \right] $, and $c=\left[ \begin{array}{r} 7 \\
6 \\
3 \\
4 \\
\end{array} \right]$</span>. </p><p>Here is how to set up the canonical LP <span>$\min c^T x$</span> s.t. <span>$Ax\ge b, x\ge0$</span>:</p><pre><code class="nohighlight hljs">julia&gt; A = [7 5 2 9; 5 9 5 5];

julia&gt; b = [2, 5];

julia&gt; c = [7, 6, 3, 4];

julia&gt; T = Tableau(A, b, c)
┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │  -7 │  -6 │  -3 │  -4 │   0 │   0 │   0 │
├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│   Cons 1 │ 0 │   7 │   5 │   2 │   9 │  -1 │   0 │   2 │
│   Cons 2 │ 0 │   5 │   9 │   5 │   5 │   0 │  -1 │   5 │
└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘</code></pre><p>Note that <span>$x_5$</span> and <span>$x_6$</span> are added as slack variables. Therefore the first constraint is <span>$7x_1 + 5x_2 +2 x_3 +9x_4 - x_5=2$</span> which is equivalent to <span>$7x_1 + 5x_2 +2 x_3 +9x_4 \ge 2$</span>. With these extra variables, the LP is now in standard form.</p><p>The objective function is <span>$z = 7x_1 + 6x_2 + 3x_3 + 4x_4$</span> that is encoded in the tableau  as <span>$z-7x_1 -6x_2 -3x_3 -4x_4=0$</span>. </p><h2 id="Pivoting"><a class="docs-heading-anchor" href="#Pivoting">Pivoting</a><a id="Pivoting-1"></a><a class="docs-heading-anchor-permalink" href="#Pivoting" title="Permalink"></a></h2><p>Pivoting is a fundamental operation in linear algebra that is used extensively in the Simplex Method. A pivot on element <span>$a_{ij}$</span> of a matrix begins by multiplying row <span>$i$</span> by <span>$1/a_{ij}$</span>. This leaves a <span>$1$</span> in position <span>$i,j$</span>. Then multiples of row <span>$i$</span> are added to the other rows so that all the other entries in column <span>$j$</span> are now <span>$0$</span>. </p><p>For example, suppose we wish to pivot on the <span>$2$</span> in this matrix:</p><p class="math-container">\[\left[
\begin{array}{r|rrrrrr|r}
1 &amp; -7 &amp; -6 &amp; -3 &amp; -4 &amp; 0 &amp; 0 &amp; 0 \\ \hline
0 &amp; 7 &amp; 5 &amp; \fbox2 &amp; 9 &amp; -1 &amp; 0 &amp; 2 \\
0 &amp; 5 &amp; 9 &amp; 5 &amp; 5 &amp; 0 &amp; -1 &amp; 5 \\
\end{array}
\right]\]</p><p>The main body of the matrix lies below the header row and between the vertical dividers. This is considered to be the <span>$1,3$</span>-entry of the matrix: this corresponds to the constraint <span>$1$</span> in the column of <span>$x_3$</span>. </p><p>First we multiply row <span>$1$</span> through by <span>$1/2$</span>:</p><p class="math-container">\[\left[
\begin{array}{r|rrrrrr|r}
1 &amp; -7 &amp; -6 &amp; -3 &amp; -4 &amp; 0 &amp; 0 &amp; 0 \\ \hline
0 &amp; 7/2 &amp; 5/2 &amp; 1 &amp; 9/2 &amp; -1/2 &amp; 0 &amp; 1 \\
0 &amp; 5 &amp; 9 &amp; 5 &amp; 5 &amp; 0 &amp; -1 &amp; 5 
\end{array}
\right]\]</p><p>Then we add <span>$3$</span> times the first row to the header (row <span>$0$</span>) and <span>$-5$</span> times the first row to the second row:</p><p class="math-container">\[\left[
\begin{array}{r|rrrrrr|r}
1 &amp; 7/2 &amp; 3/2 &amp; 0 &amp; 19/2 &amp; -3/2 &amp; 0 &amp; 3 \\ \hline
0 &amp; 7/2 &amp; 5/2 &amp; 1 &amp; 9/2 &amp; -1/2 &amp; 0 &amp; 1 \\
0 &amp; -25/2 &amp; -7/2 &amp; 0 &amp; -35/2 &amp; 5/2 &amp; -1 &amp; 0 \\
\end{array}
\right]\]</p><p>In the <code>SimplexTableau</code> module, this operation is accomplished with the <code>pivot!</code> function:</p><pre><code class="nohighlight hljs">julia&gt; T
┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │  -7 │  -6 │  -3 │  -4 │   0 │   0 │   0 │
├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│   Cons 1 │ 0 │   7 │   5 │   2 │   9 │  -1 │   0 │   2 │
│   Cons 2 │ 0 │   5 │   9 │   5 │   5 │   0 │  -1 │   5 │
└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘


julia&gt; pivot!(T,1,3)
[ Info: Unable to infer basis
┌──────────┬───┬───────┬──────┬─────┬───────┬──────┬─────┬─────┐
│          │ z │   x_1 │  x_2 │ x_3 │   x_4 │  x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │   7/2 │  3/2 │   0 │  19/2 │ -3/2 │   0 │   3 │
├──────────┼───┼───────┼──────┼─────┼───────┼──────┼─────┼─────┤
│   Cons 1 │ 0 │   7/2 │  5/2 │   1 │   9/2 │ -1/2 │   0 │   1 │
│   Cons 2 │ 0 │ -25/2 │ -7/2 │   0 │ -35/2 │  5/2 │  -1 │   0 │
└──────────┴───┴───────┴──────┴─────┴───────┴──────┴─────┴─────┘</code></pre><h2 id="Bases"><a class="docs-heading-anchor" href="#Bases">Bases</a><a id="Bases-1"></a><a class="docs-heading-anchor-permalink" href="#Bases" title="Permalink"></a></h2><p>The Simplex Method begins by finding a set of <span>$m$</span> columns (where <span>$m$</span> is the number of  constraints) that are linearly independent. We pivot on elements of those columns to  transform them into standard basis vectors. That is, in each of those columns there is a single <span>$1$</span>  all other elements of that column are <span>$0$</span> (including in the header).</p><p>In the example we just considered, we see that pivoting on the <span>$-1$</span> in the <span>$(2,6)$</span> position  will result in columns <span>$3$</span> and <span>$6$</span> forming a basis, and so those columns are called <em>basic</em>. </p><pre><code class="nohighlight hljs">julia&gt; T
┌──────────┬───┬───────┬──────┬─────┬───────┬──────┬─────┬─────┐
│          │ z │   x_1 │  x_2 │ x_3 │   x_4 │  x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │   7/2 │  3/2 │   0 │  19/2 │ -3/2 │   0 │   3 │
├──────────┼───┼───────┼──────┼─────┼───────┼──────┼─────┼─────┤
│   Cons 1 │ 0 │   7/2 │  5/2 │   1 │   9/2 │ -1/2 │   0 │   1 │
│   Cons 2 │ 0 │ -25/2 │ -7/2 │   0 │ -35/2 │  5/2 │  -1 │   0 │
└──────────┴───┴───────┴──────┴─────┴───────┴──────┴─────┴─────┘

julia&gt; pivot!(T,2,6)
┌──────────┬───┬──────┬─────┬─────┬──────┬──────┬─────┬─────┐
│          │ z │  x_1 │ x_2 │ x_3 │  x_4 │  x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │  7/2 │ 3/2 │   0 │ 19/2 │ -3/2 │   0 │   3 │
├──────────┼───┼──────┼─────┼─────┼──────┼──────┼─────┼─────┤
│   Cons 1 │ 0 │  7/2 │ 5/2 │   1 │  9/2 │ -1/2 │   0 │   1 │
│   Cons 2 │ 0 │ 25/2 │ 7/2 │   0 │ 35/2 │ -5/2 │   1 │   0 │
└──────────┴───┴──────┴─────┴─────┴──────┴──────┴─────┴─────┘

julia&gt; get_basis(T)
2-element Vector{Int64}:
 3
 6</code></pre><p>The <code>get_basis</code> function returns the current basis. If the tableau does not have a basis, a vector of all zeros is returned. </p><p>On the computer display, the labels of the basic columns are green. </p><p><img src="../basic-tableau.png" alt/></p><h3 id="Setting-a-basis"><a class="docs-heading-anchor" href="#Setting-a-basis">Setting a basis</a><a id="Setting-a-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-a-basis" title="Permalink"></a></h3><p>The function <code>set_basis!</code> is used to select columns to be a basis. This is invoked as  <code>set_basis(T, B)</code> where <code>B</code> is a list of <span>$m$</span> indices specifying the columns to form a basis. </p><p>For example:</p><pre><code class="nohighlight hljs">julia&gt; set_basis!(T,[2,4])
┌──────────┬───┬────────┬─────┬──────┬─────┬───────┬────────┬──────┐
│          │ z │    x_1 │ x_2 │  x_3 │ x_4 │   x_5 │    x_6 │  RHS │
│ Obj Func │ 1 │ -45/14 │   0 │  1/4 │   0 │ -3/28 │ -17/28 │ 13/4 │
├──────────┼───┼────────┼─────┼──────┼─────┼───────┼────────┼──────┤
│   Cons 1 │ 0 │   5/28 │   1 │  5/8 │   0 │  5/56 │  -9/56 │  5/8 │
│   Cons 2 │ 0 │  19/28 │   0 │ -1/8 │   1 │ -9/56 │   5/56 │ -1/8 │
└──────────┴───┴────────┴─────┴──────┴─────┴───────┴────────┴──────┘</code></pre><p>However, this basis is not suitable for the Simplex Algorithm because the RHS column contains negative numbers. In other words, <span>$\{2,4\}$</span>  is an <em>infeasible</em> basis. On the other hand <span>$\{3,6\}$</span> yields a  feasible tableau.</p><pre><code class="nohighlight hljs">julia&gt; set_basis!(T,[3,6])
┌──────────┬───┬──────┬─────┬─────┬──────┬──────┬─────┬─────┐
│          │ z │  x_1 │ x_2 │ x_3 │  x_4 │  x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │  7/2 │ 3/2 │   0 │ 19/2 │ -3/2 │   0 │   3 │
├──────────┼───┼──────┼─────┼─────┼──────┼──────┼─────┼─────┤
│   Cons 1 │ 0 │  7/2 │ 5/2 │   1 │  9/2 │ -1/2 │   0 │   1 │
│   Cons 2 │ 0 │ 25/2 │ 7/2 │   0 │ 35/2 │ -5/2 │   1 │   0 │
└──────────┴───┴──────┴─────┴─────┴──────┴──────┴─────┴─────┘</code></pre><h3 id="Automatic-basis-selection"><a class="docs-heading-anchor" href="#Automatic-basis-selection">Automatic basis selection</a><a id="Automatic-basis-selection-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-basis-selection" title="Permalink"></a></h3><p>While any <span>$m$</span> linearly independent columns may be selected to form a basis, finding a set of columns that yield a feasible tableau can be difficult. In a later section of this tutorial we describe a method for finding a basis,  but we also provide tools to make this easy.</p><p>The function <code>find_a_basis</code> automatically finds a feasible basis. Combined with <code>set_basis!</code>  the resut is a tableau that has been pivoted to a feasible configuation. </p><pre><code class="nohighlight hljs">julia&gt; T
┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │  -7 │  -6 │  -3 │  -4 │   0 │   0 │   0 │
├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│   Cons 1 │ 0 │   7 │   5 │   2 │   9 │  -1 │   0 │   2 │
│   Cons 2 │ 0 │   5 │   9 │   5 │   5 │   0 │  -1 │   5 │
└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘


julia&gt; find_a_basis(T)
2-element Vector{Int64}:
 2
 5

julia&gt; set_basis!(T,[2,5])
┌──────────┬───┬───────┬─────┬─────┬───────┬─────┬──────┬──────┐
│          │ z │   x_1 │ x_2 │ x_3 │   x_4 │ x_5 │  x_6 │  RHS │
│ Obj Func │ 1 │ -11/3 │   0 │ 1/3 │  -2/3 │   0 │ -2/3 │ 10/3 │
├──────────┼───┼───────┼─────┼─────┼───────┼─────┼──────┼──────┤
│   Cons 1 │ 0 │   5/9 │   1 │ 5/9 │   5/9 │   0 │ -1/9 │  5/9 │
│   Cons 2 │ 0 │ -38/9 │   0 │ 7/9 │ -56/9 │   1 │ -5/9 │  7/9 │
└──────────┴───┴───────┴─────┴─────┴───────┴─────┴──────┴──────┘</code></pre><p>Alternatively, using <code>set_basis!(T)</code>, without specifying a basis,   invokes <code>find_a_basis</code> to choose the basis for you. </p><p>If the tableau does not have a feasible basis, <code>find_a_basis</code> returns a vector of all zeros.</p><pre><code class="nohighlight hljs">julia&gt; T
┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┐
│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ RHS │
│ Obj Func │ 1 │  -3 │  -1 │  -5 │  -2 │  -5 │   0 │
├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┤
│   Cons 1 │ 0 │   3 │   2 │   2 │   2 │   3 │   4 │
│   Cons 2 │ 0 │   4 │   4 │   3 │   5 │   2 │   2 │
│   Cons 3 │ 0 │   1 │   2 │   4 │   2 │   1 │   1 │
└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┘


julia&gt; find_a_basis(T)
[ Info: No basis found.
3-element Vector{Int64}:
 0
 0
 0</code></pre><h3 id="Listing-all-feasible-bases"><a class="docs-heading-anchor" href="#Listing-all-feasible-bases">Listing all feasible bases</a><a id="Listing-all-feasible-bases-1"></a><a class="docs-heading-anchor-permalink" href="#Listing-all-feasible-bases" title="Permalink"></a></h3><p>The function <code>find_all_bases</code> returns a list of all feasible bases for a tableau:</p><pre><code class="nohighlight hljs">julia&gt; T
┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │
├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │
│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │
│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │
└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘


julia&gt; find_all_bases(T)
6-element Vector{Vector{Int64}}:
 [1, 2, 3]
 [1, 3, 4]
 [1, 3, 6]
 [2, 3, 5]
 [3, 4, 5]
 [3, 5, 6]</code></pre><blockquote><p>The <code>find_all_bases</code> function is highly inefficient and only suitable for small linear programs. </p></blockquote><h2 id="Simplex-Method"><a class="docs-heading-anchor" href="#Simplex-Method">Simplex Method</a><a id="Simplex-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Simplex-Method" title="Permalink"></a></h2><p>The Simplex Method finds the minimum objective value for a linear program, as well as the  vector at which that minimum is achieved. </p><h3 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h3><p>The steps in the Simplex Method are:</p><ol><li>Select a feasible starting basis. (If there is no such basis, the LP is infeasible.)</li><li>Find a column headed by a positive number. (If there are none, the LP has reached an optimal state.)</li><li>Form the ratios between the righthand column and the positive members of the column selected in step 2. </li><li>Pivot on whichever entry in the selected column gives the lowest ratio. (If there are no positive numbers in the selected column, the LP is unbounded.)</li><li>Go to step 2. </li></ol><h3 id="Manual-execution-of-the-Simplex-Algorithm"><a class="docs-heading-anchor" href="#Manual-execution-of-the-Simplex-Algorithm">Manual execution of the Simplex Algorithm</a><a id="Manual-execution-of-the-Simplex-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-execution-of-the-Simplex-Algorithm" title="Permalink"></a></h3><p>The first step is to find a first basis for a tableau <code>T</code> either:</p><ul><li>Use <code>B = find_a_basis(T); set_basis!(T,B)</code> or more simply</li><li><code>set_basis!(T)</code>.</li></ul><pre><code class="nohighlight hljs">julia&gt; T
┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │
├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │
│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │
│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │
└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘


julia&gt; set_basis!(T)
┌──────────┬───┬─────────┬──────────┬─────┬─────┬─────┬──────────┬────────┐
│          │ z │     x_1 │      x_2 │ x_3 │ x_4 │ x_5 │      x_6 │    RHS │
│ Obj Func │ 1 │ 795/284 │ -931/142 │   0 │   0 │   0 │ 1265/284 │ 334/71 │
├──────────┼───┼─────────┼──────────┼─────┼─────┼─────┼──────────┼────────┤
│   Cons 1 │ 0 │ 187/284 │ -117/142 │   1 │   0 │   0 │   85/284 │ 110/71 │
│   Cons 2 │ 0 │   -1/71 │    62/71 │   0 │   1 │   0 │     6/71 │   6/71 │
│   Cons 3 │ 0 │ 115/284 │  -15/142 │   0 │   0 │   1 │  -51/284 │   5/71 │
└──────────┴───┴─────────┴──────────┴─────┴─────┴─────┴──────────┴────────┘</code></pre><p>Later, we show how to find a first basis manually. See <em>Finding a first basis</em> later in this tutorial. </p><hr/><p>Next we need to select a column in which to pivot. In this example, there are two columns headed by positive numbers: Column 1 is headed by 795/284 and column 6 is headed by 1265/284.</p><p>It is possible to use the function <code>find_pivot(T)</code> to select the element on which to pivot.</p><pre><code class="nohighlight hljs">julia&gt; find_pivot(T)
(2, 6)</code></pre><p>This tells us to pivot at the <span>$(2,6)$</span>-entry of the tableau (where we see the value <span>$6/71$</span>). </p><p>While the <code>find_pivot</code> function suggested we pivot in column 6, we see that column 1 is also headed by a positive number, so we have the option to select a pivot there.  We can use the <code>ratios</code> functions to calculate the appropriate pivot for a user-selected column. </p><pre><code class="nohighlight hljs">julia&gt; T
┌──────────┬───┬─────────┬──────────┬─────┬─────┬─────┬──────────┬────────┐
│          │ z │     x_1 │      x_2 │ x_3 │ x_4 │ x_5 │      x_6 │    RHS │
│ Obj Func │ 1 │ 795/284 │ -931/142 │   0 │   0 │   0 │ 1265/284 │ 334/71 │
├──────────┼───┼─────────┼──────────┼─────┼─────┼─────┼──────────┼────────┤
│   Cons 1 │ 0 │ 187/284 │ -117/142 │   1 │   0 │   0 │   85/284 │ 110/71 │
│   Cons 2 │ 0 │   -1/71 │    62/71 │   0 │   1 │   0 │     6/71 │   6/71 │
│   Cons 3 │ 0 │ 115/284 │  -15/142 │   0 │   0 │   1 │  -51/284 │   5/71 │
└──────────┴───┴─────────┴──────────┴─────┴─────┴─────┴──────────┴────────┘


julia&gt; ratios(T,1)
  Ratios for column 1 headed by 795/284
          Best pivot is in row 3
┌────────────┬──────────┬────────┬───────┐
│ Constraint │ Column 1 │    RHS │ Ratio │
├────────────┼──────────┼────────┼───────┤
│          1 │  187/284 │ 110/71 │ 40/17 │
│          2 │    -1/71 │   6/71 │   --- │
│          3 │  115/284 │   5/71 │  4/23 │
└────────────┴──────────┴────────┴───────┘</code></pre><p>This analysis shows that if we decide to pivot in column 1, we should do so at the <span>$(3,1)$</span>-entry. Here is the result:</p><pre><code class="nohighlight hljs">julia&gt; pivot!(T,3,1)
┌──────────┬───┬─────┬─────────┬─────┬─────┬──────────┬─────────┬───────┐
│          │ z │ x_1 │     x_2 │ x_3 │ x_4 │      x_5 │     x_6 │   RHS │
│ Obj Func │ 1 │   0 │ -134/23 │   0 │   0 │  -159/23 │  131/23 │ 97/23 │
├──────────┼───┼─────┼─────────┼─────┼─────┼──────────┼─────────┼───────┤
│   Cons 1 │ 0 │   0 │  -15/23 │   1 │   0 │ -187/115 │  68/115 │ 33/23 │
│   Cons 2 │ 0 │   0 │   20/23 │   0 │   1 │    4/115 │   9/115 │  2/23 │
│   Cons 3 │ 0 │   1 │   -6/23 │   0 │   0 │  284/115 │ -51/115 │  4/23 │
└──────────┴───┴─────┴─────────┴─────┴─────┴──────────┴─────────┴───────┘</code></pre><p>Now the column 6 is the only one headed by a positive number. We can use <code>find_pivot(T)</code> or use <code>ratios</code> to find the smallest ratio:</p><pre><code class="nohighlight hljs">julia&gt; ratios(T,6)
   Ratios for column 6 headed by 131/23
          Best pivot is in row 2
┌────────────┬──────────┬───────┬────────┐
│ Constraint │ Column 6 │   RHS │  Ratio │
├────────────┼──────────┼───────┼────────┤
│          1 │   68/115 │ 33/23 │ 165/68 │
│          2 │    9/115 │  2/23 │   10/9 │
│          3 │  -51/115 │  4/23 │    --- │
└────────────┴──────────┴───────┴────────┘</code></pre><p>Pivoting at <span>$(2,6)$</span>:</p><pre><code class="nohighlight hljs">julia&gt; pivot!(T,2,6)
┌──────────┬───┬─────┬────────┬─────┬────────┬───────┬─────┬───────┐
│          │ z │ x_1 │    x_2 │ x_3 │    x_4 │   x_5 │ x_6 │   RHS │
│ Obj Func │ 1 │   0 │ -622/9 │   0 │ -655/9 │ -85/9 │   0 │ -19/9 │
├──────────┼───┼─────┼────────┼─────┼────────┼───────┼─────┼───────┤
│   Cons 1 │ 0 │   0 │  -65/9 │   1 │  -68/9 │ -17/9 │   0 │   7/9 │
│   Cons 2 │ 0 │   0 │  100/9 │   0 │  115/9 │   4/9 │   1 │  10/9 │
│   Cons 3 │ 0 │   1 │   14/3 │   0 │   17/3 │   8/3 │   0 │   2/3 │
└──────────┴───┴─────┴────────┴─────┴────────┴───────┴─────┴───────┘</code></pre><p>There are no positive entries in the top row signalling that the tableau has reached its optimal state. This is verified by the <code>status</code> function:</p><pre><code class="nohighlight hljs">julia&gt; status(T)
:optimal</code></pre><p>Finally, we get the minimum value and the vector that attains that value:</p><pre><code class="nohighlight hljs">julia&gt; value(T)
-19//9

julia&gt; basic_vector(T)
6-element Vector{Rational}:
  2//3
   0
  7//9
   0
   0
 10//9</code></pre><h3 id="Fully-automatic-execution-of-the-Simplex-Algorithm"><a class="docs-heading-anchor" href="#Fully-automatic-execution-of-the-Simplex-Algorithm">Fully automatic execution of the Simplex Algorithm</a><a id="Fully-automatic-execution-of-the-Simplex-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Fully-automatic-execution-of-the-Simplex-Algorithm" title="Permalink"></a></h3><p>The <code>simplex_solve!</code> function does all the steps of the Simplex Method without requiring any interaction with the user. We return the tableau <code>T</code> to its original state with <code>restore!(T)</code> and then solve the LP using <code>simplex_solver</code>:</p><pre><code class="nohighlight hljs">julia&gt; restore!(T)
┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │
├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │
│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │
│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │
└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘

julia&gt; simplex_solve!(T)
[ Info: Finding an initial basis.
Starting basis found: [3, 4, 5]
Starting tableau

┌──────────┬───┬─────────┬──────────┬─────┬─────┬─────┬──────────┬────────┐
│          │ z │     x_1 │      x_2 │ x_3 │ x_4 │ x_5 │      x_6 │    RHS │
│ Obj Func │ 1 │ 795/284 │ -931/142 │   0 │   0 │   0 │ 1265/284 │ 334/71 │
├──────────┼───┼─────────┼──────────┼─────┼─────┼─────┼──────────┼────────┤
│   Cons 1 │ 0 │ 187/284 │ -117/142 │   1 │   0 │   0 │   85/284 │ 110/71 │
│   Cons 2 │ 0 │   -1/71 │    62/71 │   0 │   1 │   0 │     6/71 │   6/71 │
│   Cons 3 │ 0 │ 115/284 │  -15/142 │   0 │   0 │   1 │  -51/284 │   5/71 │
└──────────┴───┴─────────┴──────────┴─────┴─────┴─────┴──────────┴────────┘

Pivot 1 at (2, 6)

┌──────────┬───┬───────┬─────────┬─────┬──────────┬─────┬─────┬─────┐
│          │ z │   x_1 │     x_2 │ x_3 │      x_4 │ x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │ 85/24 │ -631/12 │   0 │ -1265/24 │   0 │   0 │ 1/4 │
├──────────┼───┼───────┼─────────┼─────┼──────────┼─────┼─────┼─────┤
│   Cons 1 │ 0 │ 17/24 │  -47/12 │   1 │   -85/24 │   0 │   0 │ 5/4 │
│   Cons 2 │ 0 │  -1/6 │    31/3 │   0 │     71/6 │   0 │   1 │   1 │
│   Cons 3 │ 0 │   3/8 │     7/4 │   0 │     17/8 │   1 │   0 │ 1/4 │
└──────────┴───┴───────┴─────────┴─────┴──────────┴─────┴─────┴─────┘

Pivot 2 at (3, 1)

┌──────────┬───┬─────┬────────┬─────┬────────┬───────┬─────┬───────┐
│          │ z │ x_1 │    x_2 │ x_3 │    x_4 │   x_5 │ x_6 │   RHS │
│ Obj Func │ 1 │   0 │ -622/9 │   0 │ -655/9 │ -85/9 │   0 │ -19/9 │
├──────────┼───┼─────┼────────┼─────┼────────┼───────┼─────┼───────┤
│   Cons 1 │ 0 │   0 │  -65/9 │   1 │  -68/9 │ -17/9 │   0 │   7/9 │
│   Cons 2 │ 0 │   0 │  100/9 │   0 │  115/9 │   4/9 │   1 │  10/9 │
│   Cons 3 │ 0 │   1 │   14/3 │   0 │   17/3 │   8/3 │   0 │   2/3 │
└──────────┴───┴─────┴────────┴─────┴────────┴───────┴─────┴───────┘

Optimality reached. Pivot count = 2
Minimal value = -19/9 = -2.111111111111111
6-element Vector{Rational}:
  2//3
   0
  7//9
   0
   0
 10//9</code></pre><h3 id="Numerically"><a class="docs-heading-anchor" href="#Numerically">Numerically</a><a id="Numerically-1"></a><a class="docs-heading-anchor-permalink" href="#Numerically" title="Permalink"></a></h3><p>The function <code>lp_solve</code> also solves linear programs but uses floating point rather than exact arithmetic. It uses the <a href="https://ergo-code.github.io/HiGHS/stable/">HiGHS</a> solver to find the optimal solution: </p><pre><code class="nohighlight hljs">julia&gt; lp_solve(T)
Minimal objective value = -2.1111111111111183

6-element Vector{Float64}:
 0.6666666666666666
 0.0
 0.7777777777777776
 0.0
 0.0
 1.1111111111111127</code></pre><h2 id="Finding-a-First-Basis"><a class="docs-heading-anchor" href="#Finding-a-First-Basis">Finding a First Basis</a><a id="Finding-a-First-Basis-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-a-First-Basis" title="Permalink"></a></h2><p>Given a (standard form) linear program with <span>$n$</span> variables and <span>$m$</span> constraints, we form an  auxilliary LP as follows: </p><ol><li>Create <span>$m$</span> additional variables, <span>$x_{n+1}, x_{n+2},\ldots,x_{n+m}$</span>.</li><li>If a constraint has a negative right-hand side, multiply both sides by <span>$-1$</span>. This ensures that all constraints have a nonnegative right-hand side. </li><li>Add a <span>${}+x_{n+i}$</span> term to the left-hand side of constraint <span>$i$</span> for <span>$i=1,2,\ldots,m$</span>. </li><li>Use <span>$x_{n+1} + x_{n+2} + \cdots + x_{n+m}$</span> as the objective function to be minimized.</li></ol><p>In this new tableau, it is immediate that the new, auxilliary columns form a feasible basis. </p><p>Use the function <code>phase_one_tableau</code> build this auxilliary tableau from the original:</p><pre><code class="nohighlight hljs">julia&gt; T
┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ RHS │
│ Obj Func │ 1 │   0 │  -3 │  -3 │   1 │  -2 │   4 │   0 │
├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│   Cons 1 │ 0 │   1 │   8 │  -2 │   8 │   6 │  -1 │  -2 │  # note the RHS of row 1 is negative
│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   4 │
│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   9 │
└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘


julia&gt; TT = phase_one_tableau(T)
┌──────────┬───┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│          │ z │ x_1 │ x_2 │ x_3 │ x_4 │ x_5 │ x_6 │ x_7 │ x_8 │ x_9 │ RHS │
│ Obj Func │ 1 │   7 │   1 │   9 │  10 │   3 │   3 │   0 │   0 │   0 │  15 │
├──────────┼───┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┤
│   Cons 1 │ 0 │  -1 │  -8 │   2 │  -8 │  -6 │   1 │   1 │   0 │   0 │   2 │ 
│   Cons 2 │ 0 │   2 │   6 │   2 │   9 │   2 │   1 │   0 │   1 │   0 │   4 │
│   Cons 3 │ 0 │   6 │   3 │   5 │   9 │   7 │   1 │   0 │   0 │   1 │   9 │
└──────────┴───┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘

julia&gt; get_basis(TT)
3-element Vector{Int64}:
 7
 8
 9</code></pre><p>We now solve <code>TT</code> by the Simplex Method either manually or automatically:</p><pre><code class="nohighlight hljs">julia&gt; simplex_solve!(TT, false);   # the false argument supresses the verbose output

julia&gt; TT
┌──────────┬───┬─────────┬──────────┬─────┬─────┬─────┬─────────┬─────────┬─────────┬────────┬────────┐
│          │ z │     x_1 │      x_2 │ x_3 │ x_4 │ x_5 │     x_6 │     x_7 │     x_8 │    x_9 │    RHS │
│ Obj Func │ 1 │       0 │        0 │   0 │   0 │   0 │       0 │      -1 │      -1 │     -1 │      0 │
├──────────┼───┼─────────┼──────────┼─────┼─────┼─────┼─────────┼─────────┼─────────┼────────┼────────┤
│   Cons 1 │ 0 │ 187/284 │ -117/142 │   1 │   0 │   0 │  85/284 │  45/284 │   1/142 │ 19/142 │ 110/71 │
│   Cons 2 │ 0 │   -1/71 │    62/71 │   0 │   1 │   0 │    6/71 │   -1/71 │   11/71 │  -4/71 │   6/71 │
│   Cons 3 │ 0 │ 115/284 │  -15/142 │   0 │   0 │   1 │ -51/284 │ -27/284 │ -29/142 │ 17/142 │   5/71 │
└──────────┴───┴─────────┴──────────┴─────┴─────┴─────┴─────────┴─────────┴─────────┴────────┴────────┘

julia&gt; value(TT)
0//1

julia&gt; get_basis(TT)
3-element Vector{Int64}:
 3
 4
 5</code></pre><p>Because the value of the final auxilliary tableau is zero, its basis is the starting basis for <code>T</code>.</p><blockquote><p>If the final value for the auxilliary tableau is not zero, then the original tableau is infeasible. </p></blockquote></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Overview</a><a class="docs-footer-nextpage" href="../other/">Other Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Thursday 25 September 2025 15:10">Thursday 25 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
